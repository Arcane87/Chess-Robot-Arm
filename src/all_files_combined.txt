----- D:\chessweb\src\App.tsx -----
import { useEffect, useRef, useState } from "react";
import { Outlet } from "react-router-dom";
import { ModelRefs } from "./types";
import * as tf from "@tensorflow/tfjs-core";
import "@tensorflow/tfjs-backend-webgl";
import { getStockfishEngine } from "./utils/stockfish";

const App = () => {
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  const piecesModelRef = useRef<any>();
  const xcornersModelRef = useRef<any>();
  const modelRefs: ModelRefs = {
    "piecesModelRef": piecesModelRef,
    "xcornersModelRef": xcornersModelRef,           
  }

  useEffect(() => {
    const initTensorFlow = async () => {
      try {
        // Initialize TensorFlow backend
        await tf.setBackend('webgl');
        await tf.ready();
        console.log("TensorFlow backend:", tf.getBackend());
        
        // Initialize Stockfish (but don't wait for it)
        setTimeout(() => {
          getStockfishEngine();
          console.log("Stockfish engine initialized");
        }, 1000);
        
        setLoading(false);
      } catch (err: any) {
        console.error("TensorFlow initialization error:", err);
        setError(`TensorFlow Error: ${err.message}`);
        setLoading(false);
      }
    };
    
    initTensorFlow();
  }, []);

  if (error) {
    return (
      <div style={{ padding: '20px', color: 'white', backgroundColor: '#333', height: '100vh' }}>
        <h2>Error</h2>
        <p>{error}</p>
        <p>Please make sure WebGL is enabled in your browser.</p>
        <button onClick={() => window.location.reload()}>Reload</button>
      </div>
    );
  }

  return (
    <>
      {!loading && <Outlet context={modelRefs}/>}
      {loading && (
        <div style={{ padding: '20px', color: 'white', backgroundColor: '#333', height: '100vh' }}>
          <h2>Loading TensorFlow...</h2>
          <p>Please wait while TensorFlow initializes.</p>
        </div>
      )}
    </>
  );
};

export default App;

----- D:\chessweb\src\index.tsx -----
import 'bootstrap/dist/js/bootstrap.bundle.min.js';
import 'bootstrap/dist/css/bootstrap.min.css';
import Home from "./components/home/home";
import Export from "./components/export/export";
import FAQ from "./components/faq/faq";
import App from "./App";
import TestStockfish from "./components/test/TestStockfish"; // Add this import

import { createRoot } from 'react-dom/client';
import "./style/index.css";
import { createBrowserRouter, RouterProvider } from "react-router-dom";
import { Provider } from 'react-redux';
import store from "./store.tsx";
import { persistStore } from "redux-persist";
import { PersistGate } from "redux-persist/integration/react";
import { registerSW } from "virtual:pwa-register";
import { VideoAndSidebar } from './components/common';

// add this to prompt for a refresh
const updateSW = registerSW({
  onNeedRefresh() {
    if (confirm("New content available. Reload?")) {
      localStorage.clear();
      updateSW(true);
    }
  },
});

const router = createBrowserRouter([
  {
    path: "/",
    element: <App />,
    children: [
      {
        path: "",
        element: <Home />,
      },
      {
        path: "/record",
        element: <VideoAndSidebar mode="record" />
      },
      {
        path: "/upload",
        element: <VideoAndSidebar mode="upload" />
      },
      {
        path: "/analyze",  // Changed from broadcast
        element: <VideoAndSidebar mode="analyze" />
      },
      {
        path: "/play",
        element: <VideoAndSidebar mode="play" />
      },
      {
        path: "/export",
        element: <Export />
      },
      {
        path: "/faq",
        element: <FAQ />
      },
      {
        path: "/test-stockfish",  // ADD THIS TEST ROUTE
        element: <TestStockfish />
      }
    ]
  }
]);

const root = createRoot(document.getElementById('root')!);
const persistor = persistStore(store);

root.render(
  <Provider store={store}>
    <PersistGate persistor={persistor}>
      <RouterProvider router={router} />
    </PersistGate>
  </Provider>
);

----- D:\chessweb\src\store.tsx -----
import { configureStore } from "@reduxjs/toolkit";
import { combineReducers } from "redux";
import {
  persistReducer,
  FLUSH,
  REHYDRATE,
  PAUSE,
  PERSIST,
  PURGE,
  REGISTER,
} from 'redux-persist'
import storage from "redux-persist/lib/storage";
import { cornersReducer, gameReducer, userReducer } from "./slices";

const reducer = combineReducers({
  game: gameReducer,
  corners: cornersReducer,
  user: userReducer
})

const persistConfig = {
  key: "root",
  version: 1,
  storage,
  blacklist: []
};

const persistedReducer = persistReducer(persistConfig, reducer);

const store = configureStore({
  reducer: persistedReducer,
  middleware: (getDefaultMiddleware) =>
  getDefaultMiddleware({
    serializableCheck: {
      ignoredActions: [FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER],
    },
  }),
});

export default store;

----- D:\chessweb\src\types.tsx -----
// =========================
// Core domain models
// =========================

interface Study {
  id: string
  name: string
}

interface ModelRefs {
  piecesModelRef: any
  xcornersModelRef: any
}

interface MovesData {
  sans: string[]
  from: number[]
  to: number[]
  targets: number[]
}

interface MovesPair {
  move1: MovesData
  move2: MovesData | null
  moves: MovesData | null
}

type CornersKey = "h1" | "a1" | "a8" | "h8"

interface CornersPayload {
  key: CornersKey
  xy: number[]
}

type CornersDict = { [key in CornersKey]: number[] }

interface Game {
  fen: string
  moves: string
  start: string
  lastMove: string
  greedy: boolean
}

interface User {
  username: string
}

interface RootState {
  game: Game
  corners: CornersDict
  user: User
}

// =========================
// App / UI state
// =========================

type Mode = "record" | "upload" | "analyze" | "play"

// =========================
// Camera / Device handling
// =========================

/**
 * Supported camera device types
 * - webcam   â†’ browser MediaDevices
 * - droidcam â†’ DroidCam / IP-based virtual camera
 */
type DeviceType = "webcam" | "droidcam"

/**
 * Unified camera device descriptor
 * Works for:
 * - navigator.mediaDevices
 * - DroidCam virtual devices
 * - future IP / RTSP sources
 */
interface CameraDevice {
  deviceId: string
  kind: MediaDeviceKind | "virtual"
  label: string
  type: DeviceType
}

// =========================
// React setters
// =========================

type SetBoolean = React.Dispatch<React.SetStateAction<boolean>>
type SetString = React.Dispatch<React.SetStateAction<string>>
type SetStringArray = React.Dispatch<React.SetStateAction<string[]>>
type SetNumber = React.Dispatch<React.SetStateAction<number>>
type SetStudy = React.Dispatch<React.SetStateAction<Study | null>>

// =========================
// Exports
// =========================

export type {
  RootState,
  Study,
  ModelRefs,
  MovesData,
  MovesPair,
  CornersDict,
  CornersKey,
  CornersPayload,
  Game,
  Mode,
  DeviceType,
  CameraDevice,
  SetBoolean,
  SetString,
  SetStringArray,
  SetNumber,
  SetStudy
}


----- D:\chessweb\src\components\broadcast\analyzeSidebar.tsx -----
import { CornersButton, Sidebar, RecordButton, StopButton, DeviceButton } from "../common";
import { SetBoolean, SetStringArray, CameraDevice } from "../../types";
import { getStockfishEvaluation } from "../../utils/stockfish";

const AnalyzeSidebar = ({ piecesModelRef, xcornersModelRef, videoRef, canvasRef, sidebarRef, 
  playing, setPlaying, text, setText, onDeviceChange }: {  // Added onDeviceChange
  piecesModelRef: any, xcornersModelRef: any, videoRef: any, canvasRef: any, sidebarRef: any,
  playing: boolean, setPlaying: SetBoolean, 
  text: string[], setText: SetStringArray,
  onDeviceChange?: (device: CameraDevice) => void  // Added
}) => {
  const inputStyle = {
    display: playing ? "none": "inline-block"
  }
  
  const handleAnalyze = async () => {
    setText(["Analyzing position..."]);
    try {
      const evalValue = await getStockfishEvaluation("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1");
      
      if (evalValue !== null) {
        const evalText = evalValue > 0 ? `+${evalValue.toFixed(2)}` : evalValue.toFixed(2);
        setText([`Evaluation: ${evalText}`, evalValue > 0 ? "White is better" : evalValue < 0 ? "Black is better" : "Equal"]);
      } else {
        setText(["Analysis failed: Could not get evaluation"]);
      }
    } catch (error) {
      console.error("Analysis error:", error);
      setText(["Analysis failed"]);
    }
  };
  
  return (
    <Sidebar sidebarRef={sidebarRef} playing={playing} text={text} setText={setText} >
      <li className="my-1" style={inputStyle}>
        <DeviceButton videoRef={videoRef} onDeviceChange={onDeviceChange} />  {/* Added onDeviceChange */}
      </li>
      <li className="my-1" style={inputStyle}>
        <CornersButton piecesModelRef={piecesModelRef} xcornersModelRef={xcornersModelRef} videoRef={videoRef} canvasRef={canvasRef} 
        setText={setText} />
      </li>
      <li className="my-1" style={inputStyle}>
        <button 
          className="btn btn-dark btn-sm btn-outline-light w-100"
          onClick={handleAnalyze}
        >
          Analyze Position
        </button>
      </li>
      <li className="my-1">
        <div className="btn-group w-100" role="group">
          <RecordButton playing={playing} setPlaying={setPlaying} />
          <StopButton setPlaying={setPlaying} setText={setText} />
        </div>
      </li>
    </Sidebar>
  );
};

export default AnalyzeSidebar;

----- D:\chessweb\src\components\broadcast\boardNumberInput.tsx -----
import { SetNumber } from "../../types";

const BoardNumberInput = ({ setBoardNumber }: {setBoardNumber: SetNumber }) => {
  const handleChange = (e: any) => {
    setBoardNumber(parseInt(e.target.value));
  }
  
  return (
    <div className="text-white">
      <label className="form-check-label" htmlFor="board">
        Board:&nbsp;
      </label>
      <input type="number" id="board" onChange={handleChange} min={1} max={64} />
    </div>
  )
}

export default BoardNumberInput;

----- D:\chessweb\src\components\common\container.tsx -----
const Container = (props: any) => {
  return (
    <div className="d-flex bg-dark h-100">
      {props.children}
    </div>
  )
}

export default Container;

----- D:\chessweb\src\components\common\corners.tsx -----
import { cornersSelect } from "../../slices/cornersSlice";
import { CornersDict } from "../../types";
import Marker from "./marker";

const Corners = () => {
  const corners: CornersDict = cornersSelect();

  return (
    <>
      <Marker name="a8" xy={corners.a8} />
      <Marker name="h8" xy={corners.h8} />
      <Marker name="h1" xy={corners.h1} />
      <Marker name="a1" xy={corners.a1} />
    </>
  );
};

export default Corners;

----- D:\chessweb\src\components\common\cornersButton.tsx -----
import { findCorners } from "../../utils/findCorners";
import { useDispatch } from 'react-redux';
import SidebarButton from "./sidebarButton";

const CornersButton = ({ piecesModelRef, xcornersModelRef, videoRef, canvasRef, setText}: 
  {piecesModelRef: any, xcornersModelRef: any, videoRef: any, canvasRef: any, setText: any}) => {
  const dispatch = useDispatch();

  const handleClick = (e: any) => {
    e.preventDefault();

    findCorners(piecesModelRef, xcornersModelRef, videoRef, canvasRef, dispatch, setText);
  }

  return (
    <SidebarButton onClick={handleClick}>
      Find Corners
    </SidebarButton>
  );
};

export default CornersButton;

----- D:\chessweb\src\components\common\deviceButton.tsx -----
import { useEffect, useState } from "react";
import { MEDIA_CONSTRAINTS } from "../../utils/constants";
import { CameraDevice } from "../../types";

const DeviceButton = ({ videoRef, onDeviceChange }: {videoRef: any, onDeviceChange?: (device: CameraDevice) => void }) => {
  const [devices, setDevices] = useState<CameraDevice[]>([]);
  const [device, setDevice] = useState<CameraDevice | null>(null);

  const handleClick = async (e: any, newDevice: CameraDevice) => {
    e.preventDefault();

    if (device?.deviceId === newDevice.deviceId) {
      return;
    }

    setDevice(newDevice);
    
    if (onDeviceChange) {
      onDeviceChange(newDevice);
    }

    if (newDevice.type === 'droidcam') {
      // For DroidCam, we don't set srcObject
      // The Video component will handle this based on deviceType
      return;
    }

    const constraints: any = {...MEDIA_CONSTRAINTS}
    constraints["video"]["deviceId"] = newDevice.deviceId
    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    videoRef.current.srcObject = stream;
  }

  useEffect(() => {
    const newDevices: CameraDevice[] = [];
    
    // Add DroidCam as a virtual device
    const droidcamDevice: CameraDevice = {
      deviceId: 'droidcam',
      kind: 'videoinput',
      label: 'DroidCam (iPhone)',
      type: 'droidcam'
    };
    newDevices.push(droidcamDevice);
    
    // Add real webcams
    navigator.mediaDevices
    .enumerateDevices()
    .then((devices) => {
      devices.forEach((device: MediaDeviceInfo) => {
        if (device.kind != "videoinput") {
          return;
        }
        newDevices.push({
          deviceId: device.deviceId,
          kind: device.kind,
          label: device.label,
          type: 'webcam'
        });
      });
      setDevices(newDevices);
    })
    .catch((err) => {
      console.error(`${err.name}: ${err.message}`);
      setDevices(newDevices); // Still include DroidCam even if webcams fail
    });
  }, [])

  return (
    <div className="dropdown">
      <button className="btn btn-dark btn-sm btn-outline-light dropdown-toggle w-100" id="deviceButton" data-bs-toggle="dropdown" aria-expanded="false">
      {(device === null) ? "Select a Device" : `Device: ${device.label}`}
      </button>
      <ul className="dropdown-menu" aria-labelledby="deviceButton">
        {devices.map(device => 
          <li key={device.deviceId}>
            <a onClick={(e) => handleClick(e, device)} className="dropdown-item" href="#">
              {device.label}
            </a>
          </li>
        )}
      </ul>
    </div>
  );
};

export default DeviceButton;

----- D:\chessweb\src\components\common\fenButton.tsx -----
import { useState } from "react";
import { findFen } from "../../utils/findFen";
import { useDispatch } from 'react-redux';
import { gameResetFen, gameResetMoves, gameResetStart } from "../../slices/gameSlice";
import { Color } from "chess.js";

const FenButton = ({ piecesModelRef, videoRef, canvasRef, setText, cornersRef }: 
  {piecesModelRef: any, videoRef: any, canvasRef: any, setText: any, cornersRef: any }) => {
  const options = ["Normal", "Infer (White to move)", "Infer (Black to move)"];
  
  const dispatch = useDispatch();
  const [option, setOption] = useState<string>(options[0]);

  const handleClick = (e: any, option: string) => {
    e.preventDefault();
    if (option === "Normal") {
      dispatch(gameResetStart());
      dispatch(gameResetMoves());
      dispatch(gameResetFen());
    } else {
      const color: Color = option.includes("White to move") ? "w" : "b";
      findFen({piecesModelRef, videoRef, cornersRef, canvasRef, dispatch, setText, color});
    }
    setOption(option);
  }

  return (
    <div className="dropdown">
      <button className="btn btn-dark btn-sm btn-outline-light dropdown-toggle w-100" id="dropdownMenuButton1" data-bs-toggle="dropdown" aria-expanded="false">
        Start: {option}
      </button>
      <ul className="dropdown-menu" aria-labelledby="dropdownMenuButton1">
        {options.map((option) => 
          <li key={option}>
            <a onClick={(e) => handleClick(e, option)} className="dropdown-item" href="#">{option}</a>
          </li>
        )}
      </ul>
    </div>
  );
};

export default FenButton;

----- D:\chessweb\src\components\common\homeButton.tsx -----
import { useNavigate } from "react-router-dom";
import SidebarButton from "./sidebarButton";
import Icon from "./icon";

const HomeButton = () => {
  const navigate = useNavigate();

  const handleClick = () => {    
    navigate("/"); 
  }
  
  return (
    <SidebarButton onClick={handleClick} >
      <Icon iconName="bi-house"/>
    </SidebarButton>
  );
};

export default HomeButton;

----- D:\chessweb\src\components\common\icon.tsx -----
const Icon = ({ iconName }: { iconName: string }) => {
  return (
    <i className={`h4 bi ${iconName}`} />
  )
}

export default Icon;

----- D:\chessweb\src\components\common\index.tsx -----
import SidebarButton from "./sidebarButton";
import CornersButton from "./cornersButton";
import RecordButton from "./recordButton";
import StopButton from "./stopButton";
import PgnButton from "./pgnButton";
import Icon from "./icon";
import Corners from "./corners";
import HomeButton from "./homeButton";
import Sidebar from "./sidebar";
import Container from "./container";
import VideoAndSidebar from "./videoAndSidebar";
import FenButton from "./fenButton";
import DeviceButton from "./deviceButton";

export { 
  SidebarButton, CornersButton, PgnButton, Icon, Corners,
  HomeButton, Sidebar, Container, VideoAndSidebar, RecordButton, StopButton, FenButton, DeviceButton,
};

----- D:\chessweb\src\components\common\marker.tsx -----
import Draggable from 'react-draggable';
import React from "react";
import { MARKER_DIAMETER } from "../../utils/constants";
import { useDispatch } from 'react-redux';
import { cornersSet } from '../../slices/cornersSlice';
import { CornersPayload, CornersKey } from '../../types';

const Marker = ({ name, xy }: { name: CornersKey, xy: number[] }) => {
  const boxStyle: React.CSSProperties = {
    "height": MARKER_DIAMETER,
    "width": MARKER_DIAMETER,
    "backgroundColor": "red",
    "borderRadius": "50%",
    "textAlign": "center",
    "position": "absolute",
    "userSelect": "none",
    "opacity": 0.5
  };
  const cursorStyle: React.CSSProperties = {
    "display": "flex",
    "height": "100%",
    "width": "100%",
    "textAlign": "center",
    "justifyContent": "center",
    "alignItems": "center"
  }
  const nodeRef = React.useRef(null);
  const dispatch = useDispatch();

  return (
    <Draggable
    handle="strong"
    bounds="parent"
    position={{"x": xy[0], "y": xy[1]}}
    defaultPosition={{"x": xy[0], "y": xy[1]}}
    nodeRef={nodeRef}
    onStop={(_, data) => {
      const payload: CornersPayload = {
        "xy": [data.x, data.y],
        "key": name
      }
      console.log(payload);
      dispatch(cornersSet(payload))
    }}
    >
      <div className="box no-cursor" style={boxStyle} ref={nodeRef}>
        <strong className="cursor" style={cursorStyle}>{name}</strong>
      </div>
    </Draggable>
  );
};

export default Marker;

----- D:\chessweb\src\components\common\pgnButton.tsx -----
import SidebarButton from "./sidebarButton";
import { SetStringArray } from "../../types";
import { gameSelect, makePgn } from "../../slices/gameSlice";

const PgnButton = ({ setText, playing }: {setText: SetStringArray, playing: boolean}) => {
  const pgn: string = makePgn(gameSelect());

  const handleClick = (e: any) => {
    e.preventDefault();

    navigator.clipboard.writeText(pgn);

    if (!playing) {
      setText(["Copied PGN"]);
    }
  }

  return (
    <SidebarButton onClick={handleClick}>
      Copy PGN
    </SidebarButton>
  );
};

export default PgnButton;

----- D:\chessweb\src\components\common\recordButton.tsx -----
import { SetBoolean } from "../../types";
import Icon from "./icon";
import SidebarButton from "./sidebarButton";

const RecordButton = ({ playing, setPlaying }: 
  { playing: boolean, setPlaying: SetBoolean }) => {
  const handleClick = (e: any) => {
    e.preventDefault();

    setPlaying(!playing);
  }

 return (
    <SidebarButton onClick={handleClick}>
      <Icon iconName={playing ? "bi-pause" : "bi-play"} />
    </SidebarButton>
  );
};

export default RecordButton;


----- D:\chessweb\src\components\common\sidebar.tsx -----
import { Chessboard } from "kokopu-react";
import { HomeButton, PgnButton } from "./index.tsx";
import { Game } from "../../types.tsx";
import { gameSelect } from "../../slices/gameSlice.tsx";

const Sidebar = (props: any) => {
  const game: Game = gameSelect();

  const boardDisplay = () => {
    return (
      <Chessboard 
        turnVisible={false} 
        squareSize={20} 
        position={game.fen}
        coordinateVisible={false}
      />
    );
  }

  const textDisplay = () => {
    return (
      <div className="text-white">
        {props.text.map(function(t: any, i: any){
            return <div key={i}>{t}</div>;
        })}
      </div>
    )
  }

  const buttons = () => {
    return (
      <div className="btn-group w-100" role="group">
        <PgnButton setText={props.setText} playing={props.playing} />
        <HomeButton />
      </div>
    );
  }

  return (
    <div ref={props.sidebarRef} className="d-flex flex-column text-center mx-1" 
      style={{"minWidth": "200px"}}>
      <ul className="nav nav-pills flex-column">
        <li className="my-1" style={{display: props.playing ? "inline-block": "none"}}>
          {boardDisplay()}
        </li>
        {props.children}
        <li className="border-top"></li>
        <li className="my-1">
          {textDisplay()}
        </li>
        <li className="border-top"></li>
        <li className="my-1">
          {buttons()}
        </li>
      </ul>
    </div>
  );
};

export default Sidebar;

----- D:\chessweb\src\components\common\sidebarButton.tsx -----
const SidebarButton = (props: any) => {
  return (
    <button onClick={props.onClick} className="btn btn-dark btn-sm btn-outline-light w-100">
      {props.children}
    </button>
  )
}

export default SidebarButton;

----- D:\chessweb\src\components\common\stopButton.tsx -----
import { useDispatch } from "react-redux";
import { SetBoolean, SetStringArray } from "../../types";
import { gameResetFen, gameResetMoves } from "../../slices/gameSlice";
import SidebarButton from "./sidebarButton";
import Icon from "./icon";

const StopButton = ({ setPlaying, setText }: { setPlaying: SetBoolean, setText: SetStringArray }) => {
  const dispatch = useDispatch();

  const handleClick = (e: any) => {
    e.preventDefault();

    setPlaying(false);
    dispatch(gameResetMoves());
    dispatch(gameResetFen());
    setText(["Reset to start position"])
  }

 return (
    <SidebarButton onClick={handleClick}>
      <Icon iconName="bi-stop" />
    </SidebarButton>
  );
};

export default StopButton;


----- D:\chessweb\src\components\common\video.tsx -----
import { findPieces } from "../../utils/findPieces";
import { useEffect, useRef, useState, useCallback } from "react";
import { CORNER_KEYS, MARKER_DIAMETER, MARKER_RADIUS, MEDIA_ASPECT_RATIO, MEDIA_CONSTRAINTS } from "../../utils/constants";
import { Corners } from ".";
import { useWindowWidth, useWindowHeight } from '@react-hook/window-size';
import { useDispatch } from 'react-redux';
import { cornersSet } from "../../slices/cornersSlice";
import { getMarkerXY, getXY } from "../../utils/detect";
import { CornersDict, Game, Mode, MovesPair, SetBoolean, SetStringArray, DeviceType } from "../../types";
import { gameSelect, makeBoard } from "../../slices/gameSlice";
import { getMovesPairs } from "../../utils/moves";
import { Chess } from "chess.js";

const Video = ({ piecesModelRef, canvasRef, videoRef, sidebarRef, playing, 
  setPlaying, playingRef, setText, mode, cornersRef, stockfishMoveRef, 
  deviceType = 'webcam', droidcamUrl = 'http://localhost:8080/video' }: {
  piecesModelRef: any, canvasRef: any, videoRef: any, sidebarRef: any, 
  playing: boolean, setPlaying: SetBoolean, playingRef: any,
  setText: SetStringArray, mode: Mode,
  cornersRef: any,
  stockfishMoveRef?: any,
  deviceType?: DeviceType,
  droidcamUrl?: string
}) => {
  const game: Game = gameSelect();

  const displayRef = useRef<any>(null);
  const boardRef = useRef<Chess>(makeBoard(game));
  const movesPairsRef = useRef<MovesPair[]>(getMovesPairs(boardRef.current));
  const lastMoveRef = useRef<string>(game.lastMove);
  const moveTextRef = useRef<string>("");
  
  // DroidCam Web Worker refs
  const droidcamWorkerRef = useRef<Worker | null>(null);
  const droidcamCanvasRef = useRef<any>(null);
  const displayCanvasRef = useRef<any>(null);
  const streamRef = useRef<MediaStream | null>(null);
  
  const [droidcamError, setDroidcamError] = useState<string>('');
  const [droidcamFps, setDroidcamFps] = useState<number>(0);
  const [workerReady, setWorkerReady] = useState<boolean>(false);

  const windowWidth = useWindowWidth();
  const windowHeight = useWindowHeight();
  const dispatch = useDispatch();

  useEffect(() => {
    const board = makeBoard(game);
    moveTextRef.current = getMoveText(board);
    if (game.greedy === true) {
      board.undo();
    } else {
      movesPairsRef.current = getMovesPairs(board);
    }
    boardRef.current = board;
    lastMoveRef.current = game.lastMove;
  }, [game])

  const getMoveText = (board: Chess): string => {
    const history: string[] = board.history();
    
    if (history.length == 0) {
      return "";
    }
  
    if (history.length == 1) {
      return `1. ${history[history.length - 1]}`
    }
  
    const firstMove: string = history[history.length - 2];
    const secondMove: string = history[history.length - 1];
    const nHalfMoves: number = Math.floor(history.length / 2);
    if (history.length % 2 == 0) {
      return `${nHalfMoves}.${firstMove} ${secondMove}`
    } 
    
    return `${nHalfMoves}...${firstMove} ${nHalfMoves + 1}.${secondMove}`
  }

  const setupWebcam = async () => {
    console.log("Setting up Webcam...");
    
    // Clean up DroidCam
    stopDroidCam();
    
    const stream = await navigator.mediaDevices.getUserMedia(MEDIA_CONSTRAINTS);
    if (videoRef.current !== null) {
      videoRef.current.srcObject = stream;
      videoRef.current.style.display = 'block';
      console.log("Webcam stream started");
    }
    return stream;
  };

  // Setup DroidCam using Web Worker
  const setupDroidCam = useCallback(() => {
    console.log("Setting up DroidCam with Web Worker...");
    setDroidcamError('');
    setDroidcamFps(0);
    setWorkerReady(false);
    
    // Stop webcam if active
    if (videoRef.current?.srcObject) {
      const stream = videoRef.current.srcObject as MediaStream;
      stream.getTracks().forEach(track => track.stop());
      videoRef.current.srcObject = null;
    }
    
    // Create canvases if they don't exist
    if (!droidcamCanvasRef.current) {
      const canvas = document.createElement('canvas');
      canvas.style.cssText = 'position: absolute; top: -1000px; left: -1000px; width: 640px; height: 480px;';
      canvas.id = 'droidcam-processing-canvas';
      document.body.appendChild(canvas);
      droidcamCanvasRef.current = canvas;
    }
    
    if (!displayCanvasRef.current) {
      const canvas = document.createElement('canvas');
      canvas.style.cssText = 'position: absolute; top: -1000px; left: -1000px; width: 640px; height: 480px;';
      canvas.id = 'droidcam-display-canvas';
      document.body.appendChild(canvas);
      displayCanvasRef.current = canvas;
    }
    
    // Create or reuse Web Worker
    if (!droidcamWorkerRef.current) {
      droidcamWorkerRef.current = new Worker(new URL('../../workers/droidcamWorker', import.meta.url));
      
      droidcamWorkerRef.current.onmessage = (event) => {
        const { type, imageBitmap, fps, frameNumber } = event.data;
        
        switch(type) {
          case 'connected':
            console.log('[Main] Worker connected');
            setWorkerReady(true);
            break;
            
          case 'frame':
            if (imageBitmap) {
              // Draw to display canvas (for video stream)
              const displayCtx = displayCanvasRef.current.getContext('2d');
              displayCanvasRef.current.width = imageBitmap.width;
              displayCanvasRef.current.height = imageBitmap.height;
              displayCtx.drawImage(imageBitmap, 0, 0);
              
              // Draw to processing canvas (for TensorFlow)
              const processCtx = droidcamCanvasRef.current.getContext('2d');
              droidcamCanvasRef.current.width = imageBitmap.width;
              droidcamCanvasRef.current.height = imageBitmap.height;
              processCtx.drawImage(imageBitmap, 0, 0);
              
              // Create/update video stream from display canvas
              if (!streamRef.current && videoRef.current) {
                streamRef.current = displayCanvasRef.current.captureStream(30);
                videoRef.current.srcObject = streamRef.current;
                videoRef.current.style.display = 'block';
                console.log('ðŸ“¹ DroidCam video stream started from Web Worker');
              }
              
              setDroidcamFps(fps);
              
              // Update FPS in UI (but don't block main thread)
              if (frameNumber % 30 === 0) {
                setText(prev => {
                  const newText = [...prev];
                  const droidcamIndex = newText.findIndex(t => t.includes('DroidCam:'));
                  if (droidcamIndex >= 0) {
                    newText[droidcamIndex] = `DroidCam: ${fps} FPS (Worker)`;
                  } else if (newText.length > 2) {
                    newText[2] = `DroidCam: ${fps} FPS (Worker)`;
                  }
                  return newText;
                });
              }
            }
            break;
            
          case 'error':
            setDroidcamError(event.data.error);
            break;
            
          case 'closed':
            setWorkerReady(false);
            break;
        }
      };
    }
    
    // Connect worker to WebSocket
    if (droidcamWorkerRef.current) {
      droidcamWorkerRef.current.postMessage({
        type: 'connect',
        url: 'ws://localhost:8080'
      });
    }
    
    return () => {
      stopDroidCam();
    };
  }, [videoRef, setText]);

  const stopDroidCam = useCallback(() => {
    console.log('Stopping DroidCam...');
    
    // Stop worker
    if (droidcamWorkerRef.current) {
      droidcamWorkerRef.current.postMessage({ type: 'disconnect' });
      droidcamWorkerRef.current.terminate();
      droidcamWorkerRef.current = null;
    }
    
    // Stop stream
    if (streamRef.current) {
      streamRef.current.getTracks().forEach(track => track.stop());
      streamRef.current = null;
    }
    
    // Clear video element
    if (videoRef.current) {
      videoRef.current.srcObject = null;
    }
    
    setWorkerReady(false);
    setDroidcamFps(0);
    setDroidcamError('');
  }, [videoRef]);

  const awaitSetupWebcam = async () => {
    if (deviceType === 'droidcam') {
      return setupDroidCam();
    }
    return setupWebcam();
  }

  const updateWidthHeight = () => {
    if (!sidebarRef.current || !displayRef.current || !canvasRef.current) {
      return;
    }
    
    if (!sidebarRef.current.offsetWidth || !displayRef.current.offsetWidth) {
      return;
    }
    
    let height = ((windowWidth - sidebarRef.current.offsetWidth - MARKER_DIAMETER) 
    / MEDIA_ASPECT_RATIO) + MARKER_DIAMETER;
    if (height > windowHeight) {
      height = windowHeight;
    }

    if ((canvasRef.current.offsetHeight == 0) || (canvasRef.current.offsetWidth) == 0) {
      return;
    }
    
    const width: number = ((height - MARKER_DIAMETER) * MEDIA_ASPECT_RATIO) + MARKER_DIAMETER;
    const oldHeight: number = canvasRef.current.height;
    const oldWidth: number = canvasRef.current.width;

    displayRef.current.style.width = `${width}px`;
    displayRef.current.style.height = `${height}px`;
    displayRef.current.width = width;
    displayRef.current.height = height;

    if (videoRef.current && videoRef.current.offsetWidth) {
      canvasRef.current.width = videoRef.current.offsetWidth;
      canvasRef.current.height = videoRef.current.offsetHeight;
    }
    
    CORNER_KEYS.forEach((key) => {
      const xy = getXY(cornersRef.current[key], oldHeight, oldWidth);
      const payload: any = {
        "xy": getMarkerXY(xy, canvasRef.current.height, canvasRef.current.width),
        "key": key
      }
      dispatch(cornersSet(payload)) 
    })
  }

  useEffect(() => {
    const initTimer = setTimeout(() => {
      updateWidthHeight();
    }, 100);

    let streamPromise: any = null;
    if (mode !== "upload") {
      streamPromise = awaitSetupWebcam()
    }

    // Start chess detection - pass the processing canvas for DroidCam
    const cleanupFindPieces = findPieces(
      piecesModelRef, 
      videoRef, 
      canvasRef, 
      playingRef, 
      setText, 
      dispatch,
      cornersRef, 
      boardRef, 
      movesPairsRef, 
      lastMoveRef, 
      moveTextRef, 
      mode, 
      stockfishMoveRef, 
      deviceType,
      droidcamCanvasRef  // Pass the processing canvas
    );

    const stopWebcam = async () => {
      if (deviceType === 'webcam') {
        const stream = await streamPromise;
        if (stream !== null) {
          stream.getTracks().forEach((track: any) => track.stop());
        }
      } else {
        stopDroidCam();
      }
    }

    return () => {
      clearTimeout(initTimer);
      if (cleanupFindPieces) {
        cleanupFindPieces();
      }
      stopWebcam();
    }
  }, [deviceType, mode, setupDroidCam, stopDroidCam]);

  useEffect(() => {
    updateWidthHeight();
  }, [windowWidth, windowHeight]);

  useEffect(() => {
    if ((mode !== "upload") || (videoRef.current.src === "")) {
      return;
    }
    
    if (playingRef.current === true) {
      videoRef.current.pause();
    } else {
      videoRef.current.play();
    }
  }, [playing])

  const canvasStyle: React.CSSProperties = {
    position: "absolute",
    left: MARKER_RADIUS,
    top: MARKER_RADIUS,
    zIndex: 10
  }

  const videoContainerStyle: React.CSSProperties = {
    width: "100%",
    height: "100%",
    padding: MARKER_RADIUS,
    position: "relative",
    overflow: "hidden"
  }

  const videoStyle: React.CSSProperties = {
    width: "100%",
    height: "100%",
    objectFit: "contain"
  }

  const liveStyle: React.CSSProperties = {
    position: "relative",
    backgroundColor: "#343a40",
  }

  const onLoadedMetadata = () => {  
    if (mode === "upload") {
      return;
    }
    window.setTimeout(() => {
      if (!(videoRef.current) || !videoRef.current.srcObject) {
        return;
      }
      
      const tracks = videoRef.current.srcObject.getVideoTracks();
      if (tracks.length == 0) {
        return;
      }

      try {
        const capabilities = tracks[0].getCapabilities();
        console.log("Capabilities", capabilities);
        
        if (capabilities.zoom) {
          tracks[0].applyConstraints({
            zoom: capabilities.zoom.min,
          })
        }
      } catch (_) {
        console.log("Cannot update track capabilities")
      }

      try {
        const settings = tracks[0].getSettings();
        console.log("Settings", settings);
      } catch (_) {
        console.log("Cannot log track settings")
      }
    }, 2000);
  };

  const onCanPlay = () => {
    updateWidthHeight();
  }

  const onEnded = () => {
    if (mode === "upload") {
      videoRef.current.currentTime = videoRef.current.duration;
      videoRef.current.pause();
    }
    setPlaying(false);
  }

  return (
    <div className="d-flex align-top justify-content-center">
      <div ref={displayRef} style={liveStyle} >
        <div className="video-container" style={videoContainerStyle} >
          <video 
            ref={videoRef} 
            autoPlay={mode !== "upload"} 
            playsInline={true} 
            muted={true}
            onLoadedMetadata={onLoadedMetadata} 
            style={{
              ...videoStyle,
              display: 'block',
              position: 'relative',
              zIndex: 1
            }} 
            onCanPlay={onCanPlay} 
            onEnded={onEnded} 
          />
          <canvas ref={canvasRef} style={canvasStyle} />
        </div>
        <Corners />
      </div>
    </div>
  );
};

export default Video;

----- D:\chessweb\src\components\common\videoAndSidebar.tsx -----
import { useRef, useState, useEffect } from "react";
import Video from "../common/video";
import { useOutletContext } from "react-router-dom";
import { useDispatch } from 'react-redux';
import { cornersReset, cornersSelect } from '../../slices/cornersSlice';
import { Container } from "../common";
import LoadModels from "../../utils/loadModels";
import { CornersDict, Mode, ModelRefs, DeviceType, CameraDevice } from "../../types"; // Added DeviceType and CameraDevice
import RecordSidebar from "../record/recordSidebar";
import UploadSidebar from "../upload/uploadSidebar";
import AnalyzeSidebar from "../broadcast/analyzeSidebar";
import { gameResetFen, gameResetMoves, gameResetStart, gameSelect } from "../../slices/gameSlice";
import { userSelect } from "../../slices/userSlice";
import { START_FEN } from "../../utils/constants";
import PlaySidebar from "../play/playSidebar";
import { useMediaQuery } from 'react-responsive';

const PortraitWarning = () => {
  return (
    <h1 className="text-white text-center w-100 p-3 h-2">
      Please use your device in landscape mode
    </h1>
  )
}

const VideoAndSidebar = ({ mode }: { mode: Mode }) => {
  const context = useOutletContext<ModelRefs>();
  const dispatch = useDispatch();
  const corners: CornersDict = cornersSelect();
  const username: string = userSelect().username; // Changed from .token to .username
  const moves: string = gameSelect().moves;
  const isPortrait = useMediaQuery({ orientation: 'portrait' });

  const [text, setText] = useState<string[]>([]);
  const [playing, setPlaying] = useState<boolean>(false);
  
  // Add state for device type
  const [deviceType, setDeviceType] = useState<DeviceType>('webcam');
  
  const videoRef = useRef<any>(null);
  const playingRef = useRef<boolean>(playing);
  const canvasRef = useRef<any>(null);
  const sidebarRef = useRef<any>(null);
  const cornersRef = useRef<CornersDict>(corners);
  const stockfishMoveRef = useRef<{ 
    sourceCoord?: number[];
    destCoord?: number[];
    uciMove?: string;
  }>({});

  useEffect(() => {
    playingRef.current = playing;
  }, [playing]);

  useEffect(() => {
    cornersRef.current = corners;
  }, [corners])

  useEffect(() => {
    LoadModels(context.piecesModelRef, context.xcornersModelRef);
    dispatch(cornersReset());
    dispatch(gameResetStart());
    dispatch(gameResetMoves());
    dispatch(gameResetFen());
  }, []);

  // Handler for device changes from DeviceButton
  const handleDeviceChange = (device: CameraDevice) => {
    setDeviceType(device.type);
    
    // Update text to show which device is active
    if (device.type === 'droidcam') {
      setText(prev => [`Switched to DroidCam`, ...prev.slice(1)]);
    } else {
      setText(prev => [`Switched to Webcam`, ...prev.slice(1)]);
    }
  };

  const props = {
    "playing": playing,
    "text": text,
    "setPlaying": setPlaying,
    "setText": setText,
    "piecesModelRef": context.piecesModelRef,
    "xcornersModelRef": context.xcornersModelRef,
    "videoRef": videoRef,
    "canvasRef": canvasRef,
    "sidebarRef": sidebarRef,
    "cornersRef": cornersRef,
    "playingRef": playingRef,
    "mode": mode,
    "stockfishMoveRef": stockfishMoveRef,
    "deviceType": deviceType,  // Added
    "droidcamUrl": "http://localhost:8080/video"  // Default DroidCam URL
  }
  
  const Sidebar = () => {
    switch(mode) {
      case "record": return <RecordSidebar {...props} onDeviceChange={handleDeviceChange} />
      case "upload": return <UploadSidebar {...props} onDeviceChange={handleDeviceChange} />
      case "play": return <PlaySidebar {...props} onDeviceChange={handleDeviceChange} />
      case "analyze": return <AnalyzeSidebar {...props} onDeviceChange={handleDeviceChange} />
    }
  }

  return (
    <Container>
      {isPortrait ? (
        <PortraitWarning />
      ) : (
        <>
          {Sidebar()}
          <Video {...props} />
        </>
      )}
    </Container>
  );
};

export default VideoAndSidebar;

----- D:\chessweb\src\components\export\board.tsx -----
import { useEffect, useState } from "react";
import { Chessboard } from "kokopu-react";
import { Chess } from "chess.js";

const Board = ({ pgn }: { pgn: string }) => {
  const [fen, setFen] = useState<string>("");

  useEffect(() => {
    try {
      const chess = new Chess();
      if (pgn.includes("[FEN")) {
        // Extract FEN from PGN header
        const fenMatch = pgn.match(/\[FEN "([^"]+)"\]/);
        if (fenMatch) {
          chess.load(fenMatch[1]);
        }
      }
      chess.loadPgn(pgn);
      setFen(chess.fen());
    } catch (error) {
      console.error("Error parsing PGN:", error);
      setFen("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1");
    }
  }, [pgn]);

  return (
    <div className="ratio ratio-21x9 d-flex justify-content-center align-items-center">
      <div style={{ width: "100%", height: "100%" }}>
        <Chessboard 
          position={fen}
          squareSize={40}
          coordinateVisible={true}
          turnVisible={true}
        />
      </div>
    </div>
  );
}

export default Board;

----- D:\chessweb\src\components\export\export.tsx -----
import ExportSidebar from "./exportSidebar";
import Board from "./board";
import { Container } from "../common";
import { gameSelect, makePgn } from "../../slices/gameSlice";

const Export = () => {
  const pgn: string = makePgn(gameSelect());

  return (
    <Container>
      <ExportSidebar pgn={pgn} />
      <Board pgn={pgn} />
    </Container>
  );
};

export default Export;

----- D:\chessweb\src\components\export\exportButton.tsx -----
import { SidebarButton } from "../common";

const ExportButton = ({ setText, pgn }: 
  { setText: any, pgn: string }) => {
  
  const saveToFile = () => {
    const blob = new Blob([pgn], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `chess_game_${new Date().toISOString().slice(0, 10)}.pgn`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    setText(["PGN saved to file"]);
  };

  return (
    <SidebarButton onClick={saveToFile}>
      Save PGN to File
    </SidebarButton>
  );
};

export default ExportButton;

----- D:\chessweb\src\components\export\exportSidebar.tsx -----
import { Sidebar } from "../common";
import React, { useState } from 'react';

const ExportSidebar = ({ pgn }: { pgn: string }) => {
  const [text, setText] = useState<string[]>(["Save PGN locally or copy to clipboard"]);

  const saveToFile = () => {
    const blob = new Blob([pgn], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `chess_game_${new Date().toISOString().slice(0, 10)}.pgn`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    setText(["PGN saved to file"]);
  };

  const copyToClipboard = () => {
    navigator.clipboard.writeText(pgn);
    setText(["PGN copied to clipboard"]);
  };

  return (
    <Sidebar playing={false} text={text} setText={setText}>
      <li className="border-top"></li>
      <li className="my-2">
        <button 
          className="btn btn-dark btn-sm btn-outline-light w-100"
          onClick={saveToFile}
        >
          Save PGN to File
        </button>
      </li>
      <li className="my-2">
        <button 
          className="btn btn-dark btn-sm btn-outline-light w-100"
          onClick={copyToClipboard}
        >
          Copy PGN to Clipboard
        </button>
      </li>
    </Sidebar>
  );
};

export default ExportSidebar;

----- D:\chessweb\src\components\faq\faq.tsx -----
// @ts-expect-error (react-faq-component has no type declaration)
import Faq from "react-faq-component";
import { HomeButton } from "../common";

const data = {
  title: "Frequently Asked Questions",
  rows: [
      {
        title: "Where can I buy a stand?",
        content: 
        <p>
          You can buy a stand for Â£12.99 at:&nbsp;  
          <a target="_blank" href="https://www.amazon.co.uk/dp/B07NVBXYPJ" rel="noreferrer">https://www.amazon.co.uk/dp/B07NVBXYPJ</a>.
        </p>
      },
      {
        title: "Is there a mobile app?",
        content:
        <p>
          If you have an Android, you can download the free ChessCam app&nbsp;
          <a target="_blank" href="https://play.google.com/store/apps/details?id=com.camerachess.www.twa" rel="noreferrer">here</a>.
          If you have an IPhone, you can add ChessCam to your home screen from the browser.
          See <a target="blank" href="https://support.google.com/chrome/answer/9658361?hl=en-GB&co=GENIE.Platform%3DiOS" rel="noreferrer">here</a> for more detail.
        </p>
      },
      {
        title: "How do I setup my camera?",
        content: 
        <div>
          <ul>
            <li>
              Place your camera on the stand to the side of the board. 
            </li>
            <li>
              Make sure that the stand is stable and that the camera can see all 4 corners.
            </li>
            <li>
              If you are using your devices native camera app and have 0.5x zoom available, use it.  
            </li>
            <li>
              Make sure that the tallest piece (the king or queen) is still in shot when placed on the furthest square from the camera.
            </li>
            <li>
              <figure className="figure">
                <img src="halfZoom.webp" className="figure-img img-fluid rounded" alt="0.5x zoom setup" />
                <figcaption className="figure-caption text-white">My setup with 0.5x zoom</figcaption>
              </figure>
            </li>
            <li>
              <figure className="figure">
                <img src="fullZoom.webp" className="figure-img img-fluid rounded" alt="1x zoom setup" />
                <figcaption className="figure-caption text-white">My setup with 1x zoom</figcaption>
              </figure>
            </li>
          </ul>
        </div>
      },
      {
        title: "Will the app work if the board or the camera move mid-way through?",
        content:
        <p>
          If the camera moves so that the squares are not aligned then the app will break.
          When the corners algorithm is fast and consistent enough the app may support a moving board/camera.
          See <a target="_blank" href="https://www.youtube.com/watch?v=XV8EKqScaKs" rel="noreferrer">https://www.youtube.com/watch?v=XV8EKqScaKs</a> for a brief demo.
        </p>
      },
      {
        title: "How powerful does my device have to be?",
        content:
        <p>
          The app works best if you can achieve at least 4 FPS. 
        </p>
      },
      {
        title: "How do I record?",
        content: 
        <ol>
          <li>
            Click the <b>Record</b> button from the Home page. 
            Alternatively, go straight to <a target="_blank" href="https://www.chesscam.net/record" rel="noreferrer">https://www.chesscam.net/record</a>.
          </li>
          <li>
            Setup your device (see "How do I set up my camera?")
          </li>
          <li>
            Click <b>Find Corners</b> to align the 4 corners with your board.
            If they are not correct, then adjust them manually.
            Clockwise the corners go "h1", "a1", "a8", "h8", starting from the bottom-right corner (relative to White).
          </li>
          <li>
            Click the <b>Play</b> button to start recording your game.
          </li>
        </ol>,
      },
      {
        title: "How do I upload a game?",
        content:
        <div>
          <ol>
            <li>
              Click the <b>Upload</b> button from the Home page. 
              Alternatively, go straight to <a target="_blank" href="https://www.chesscam.net/upload" rel="noreferrer">https://www.chesscam.net/upload</a>.
            </li>
            <li>
              Setup your device (see "How do I set up my camera?")
            </li>
            <li>
              Click <b>Find Corners</b> to align the 4 corners with your board.
              If they are not correct, then adjust them manually.
              Clockwise the corners go "h1", "a1", "a8", "h8", starting from the bottom-right corner (relative to White).
            </li>
            <li>
              Click the <b>Play</b> button to start recording your game. 
            </li>
          </ol>
          <p>
            You can adjust the speed to 1x, 2x or 4x, but you must pause the game first.
            It is recommended that you keep the speed at 1x.
          </p>
          <p>
            You can reset the video by clicking the back button.
          </p>
        </div>
      },
      {
        title: "How do I save my game?",
        content: 
        <p>
          After you have finished uploading or recording your game,
          copy it to the clipboard by clicking <b>Copy PGN</b>.
        </p>
      },
      {
        title: "How do I export my game to Lichess?",
        content:
        <div>
          This guide assumes that you have already recorded or uploaded a game successfully.
          <ol>
            <li>
              If you haven't done so already, click <b>Login</b> from the home screen.
              After giving ChessCam permissions to the Lichess API you will be redirected back to the Home screen.
            </li>
            <li>
              Click <b>Export</b> from the home screen.
            </li>
            <li>
              Choose a study that you would like to export your game to. If none are listed then go and create one on the Lichess website.
            </li>
            <li>
              Click <b>Export Game</b> to save your game to your study. It will be saved as the current timestamp.
            </li>
          </ol>
        </div>
      },
      {
        title: "Does the app work offline?",
        content:
        <p>
          If you have used the app once with an internet connection, then it will work offline in the future.
          In offline mode, you cannot export your game to Lichess, but you can still copy the PGN.
        </p>
      },
      {
        title: "How are illegal moves handled?",
        content: 
        <p>
          Illegal moves will be ignored by the app.
          There are plans to raise an alert when an illegal move is played.
        </p>
      },
      {
        title: "Are variants supported?",
        content:
        <p>
          Not at the moment.
        </p>
      },
      {
        title: "When I upload a video, is it kept private?",
        content:
        <p>
          When a video is uploaded it is processed locally ensuring full data privacy.
          ChessCam never receives any videos that a user uploads.
        </p>
      },
      {
        title: "How can I get in touch?",
        content:
        <div>
          <p>
            Message me on Lichess:&nbsp;
            <a target="_blank" href="https://lichess.org/@/BlindfoldBlunderer" rel="noreferrer">https://lichess.org/@/BlindfoldBlunderer</a>  
          </p>
          <p>
            I am always happy to chat about any ideas or problems that you might have!
          </p>
        </div>
      }
  ],
};

const styles = {
  bgColor: '#212529',
  titleTextColor: "white",
  rowTitleColor: "white",
  rowContentColor: "white",
  arrowColor: "white",
};

const FAQ = () => {
  return (
    <div className="bg-dark h-100 text-white justify-content-center">
      <Faq
        data={data}
        styles={styles}
      />
      <HomeButton />
    </div>
  );
}

export default FAQ;

----- D:\chessweb\src\components\home\header.tsx -----
import { useNavigate } from "react-router-dom";

const Header = () => {
  const navigate = useNavigate();
  
  return (
    <div className="row m-2">
      <div className="h1 col-6 h-100 d-flex justify-content-center align-items-end m-0">
        <img src="favicon.ico"></img>
        <>&nbsp;</>
        <div>ChessCam</div>
      </div>
      <div className="col-6 h-100">
        <div className="h-100 d-flex justify-content-center align-items-end m-0">
          <button className="btn btn-dark btn-outline-light m-0" onClick={() => navigate("/")}>
            Home
          </button> 
        </div>
      </div>
    </div>
  );
}

export default Header;

----- D:\chessweb\src\components\home\home.tsx -----
import Header from "./header";
import Socials from "./socials";
import NavButton from "./navButton";

const Home = () => {
  return (
    <div className="container-flex d-flex overflow-hidden h-100 flex-column p-0 m-0 text-center text-white bg-dark">
      <Header />
      <div className="row m-2">
        <div className="col">
          <NavButton text="Upload" />
        </div>
        <div className="col">
          <NavButton text="Record" />
        </div>
      </div>
      <div className="row m-2">
        <div className="col">
          <NavButton text="Analyze" />
        </div>
        <div className="col">
          <NavButton text="Play" />
        </div>
      </div>
      <div className="row m-2">
        <div className="col">
          <NavButton text="Export" />
        </div>
        <div className="col">
          <NavButton text="FAQ" />
        </div>
      </div>
      <div className="row my-2 mx-0 mt-auto">
        <Socials />
        <div key="privacy" className="col">
          <a href="/privacy" className="btn btn-dark btn-lg btn-outline-light w-20">
            Privacy
          </a>
        </div>
      </div>
    </div>
  );
};

export default Home;

----- D:\chessweb\src\components\home\navButton.tsx -----
import { useNavigate } from "react-router-dom";

const NavButton = ({ text }: { text: string }) => {
  const navigate = useNavigate();

  const handleClick = () => {
    navigate(`/${text.toLowerCase()}`);
  }

  return (
    <button 
      className="btn btn-dark btn-lg btn-outline-light w-100" 
      onClick={handleClick}
    > 
      {text}
    </button>
  )
}

export default NavButton;

----- D:\chessweb\src\components\home\socials.tsx -----
import { SocialIcon } from 'react-social-icons/component'
import 'react-social-icons/youtube'
import 'react-social-icons/github'
import 'react-social-icons/google_play'

const Socials = () => {
  const socials = [
    {"network": "github", "url": "https://github.com/Pbatch/CameraChessWeb", "bgColor": "#111111"},
    {"network": "youtube", "url": "https://www.youtube.com/channel/UCtgc3RevHj6UHq1D8Ymarmw"},
    {"network": "google_play", "url": "https://play.google.com/store/apps/details?id=com.camerachess.www.twa"}
  ]

  const icons: any[] = [];
  socials.forEach(social => {
    icons.push(
      <div key={social.network} className="col">
        <SocialIcon target="_blank" 
        network={social.network} url={social.url} bgColor={social?.bgColor} />
      </div>
    );
  });
  return icons;
};

export default Socials;

----- D:\chessweb\src\components\play\playSidebar.tsx -----
import { CornersButton, Sidebar, RecordButton, StopButton, DeviceButton } from "../common";
import { Game, SetBoolean, SetStringArray, CameraDevice } from "../../types";
import { useEffect, useRef, useState, useCallback } from "react";
import { Chess, Color } from "chess.js";
import { useDispatch } from "react-redux";
import { gameSelect, gameUpdate, makeBoard, makeUpdatePayload } from "../../slices/gameSlice";
import { getStockfishEngine } from "../../utils/stockfish";
import RobotControl from "./robotControl";
import { executeRobotMove, clearPieceBaseBuffer } from "../../utils/robotMoveExecutor";
  
const PlaySidebar = ({ piecesModelRef, xcornersModelRef, videoRef, canvasRef, sidebarRef, 
  playing, setPlaying, text, setText, cornersRef, stockfishMoveRef, onDeviceChange }: {  // Added onDeviceChange
  piecesModelRef: any, xcornersModelRef: any, videoRef: any, canvasRef: any, sidebarRef: any,
  playing: boolean, setPlaying: SetBoolean, 
  text: string[], setText: SetStringArray,
  cornersRef: any,
  stockfishMoveRef: any,
  onDeviceChange?: (device: CameraDevice) => void  // Added
}) => {
  const game: Game = gameSelect();
  const [playerColor, setPlayerColor] = useState<Color>('w');
  const [isStockfishThinking, setIsStockfishThinking] = useState(false);
  const [stockfishReady, setStockfishReady] = useState(false);
  const [executingMove, setExecutingMove] = useState(false);
  const [autoMode, setAutoMode] = useState(false);
  const [lastExecutedMove, setLastExecutedMove] = useState<string>('');
  const dispatch = useDispatch();

  // Refs to track state without triggering re-renders
  const gameRef = useRef<Game>(game);
  const playerColorRef = useRef<Color>(playerColor);
  const playingRef = useRef<boolean>(playing);
  const stockfishEngineRef = useRef(getStockfishEngine());

  // Sync refs with state
  useEffect(() => {
    gameRef.current = game;
  }, [game]);

  useEffect(() => {
    playerColorRef.current = playerColor;
  }, [playerColor]);

  useEffect(() => {
    playingRef.current = playing;
  }, [playing]);

  // Auto mode effect
  useEffect(() => {
    if (autoMode && 
        stockfishMoveRef.current?.readyForExecution && 
        stockfishMoveRef.current?.uciMove && 
        stockfishMoveRef.current?.uciMove !== lastExecutedMove) {
      handleExecuteRobotMove();
    }
  }, [stockfishMoveRef.current?.readyForExecution, autoMode, lastExecutedMove]);

  // Function to apply Stockfish move
  const applyStockfishMove = useCallback(async () => {
    if (!playingRef.current || isStockfishThinking || !stockfishReady) {
      return;
    }

    const currentGame = gameRef.current;
    const currentPlayerColor = playerColorRef.current;
    
    // Check if it's Stockfish's turn
    const colorToMove = currentGame.fen.split(" ")[1];
    if (colorToMove === currentPlayerColor) {
      return;
    }

    setIsStockfishThinking(true);

    try {
      const move = await stockfishEngineRef.current.getBestMove(currentGame.fen, 1000);
      
      if (move) {
        console.log(`Stockfish playing: ${move}`);
        
        const from = move.substring(0, 2);
        const to = move.substring(2, 4);
        const promotion = move.length > 4 ? move.substring(4, 5) : undefined;
        
        const board = makeBoard(currentGame);
        
        let isCapture = false;
        let capturedSquare = "";
        try {
          const moveObj = { from, to };
          if (promotion) {
            (moveObj as any).promotion = promotion;
          }
          
          const moveResult = board.move(moveObj);
          isCapture = !!moveResult.captured;
          capturedSquare = to;
          
          board.undo();
        } catch (error) {
          console.error("Error checking move:", error);
        }
        
        stockfishMoveRef.current = {
          uciMove: move,
          isCapture,
          capturedSquare: isCapture ? capturedSquare : ""
        };
        
        const board2 = makeBoard(currentGame);
        const legalMoves = board2.moves({ verbose: true });
        const isValidMove = legalMoves.some(m => 
          m.from === from && m.to === to && (!promotion || m.promotion === promotion)
        );
        
        if (isValidMove) {
          try {
            const moveObj = { from, to };
            if (promotion) {
              (moveObj as any).promotion = promotion;
            }
            
            board2.move(moveObj);
            const payload = makeUpdatePayload(board2);
            
            if (gameRef.current.fen === currentGame.fen) {
              dispatch(gameUpdate(payload));
              setText(prev => [
                `Stockfish played: ${move}${isCapture ? ' (Capture!)' : ''}`,
                ...prev.slice(1)
              ]);
            }
          } catch (error) {
            console.error("Error applying Stockfish move:", error);
          }
        }
      }
    } catch (error) {
      console.error("Stockfish error:", error);
    } finally {
      setIsStockfishThinking(false);
    }
  }, [dispatch, setText, isStockfishThinking, stockfishReady, stockfishMoveRef]);

  // Effect to trigger Stockfish when position changes
  useEffect(() => {
    if (!playing || isStockfishThinking || !stockfishReady) {
      return;
    }

    const colorToMove = game.fen.split(" ")[1];
    
    if (colorToMove !== playerColor) {
      const timer = setTimeout(() => {
        applyStockfishMove();
      }, 100);
      
      return () => clearTimeout(timer);
    }
  }, [game.fen, playing, playerColor, isStockfishThinking, stockfishReady, applyStockfishMove]);

  const handleExecuteRobotMove = async () => {
    const move = stockfishMoveRef.current;
    
    if (!move?.readyForExecution || !move.uciMove) {
      setText(['Move not ready for execution', 'Wait for coordinates to stabilize']);
      return;
    }
    
    setExecutingMove(true);
    setText(['Executing robot move...', 'Please wait']);
    
    try {
      const moveData = {
        sourceSquare: move.sourceSquareNumber!,
        destSquare: move.destSquareNumber!,
        sourcePieceBaseCamera: move.averagedSourcePieceBase,
        capturedPieceBaseCamera: move.averagedCapturedPieceBase,
        isCapture: move.isCapture || false,
        uciMove: move.uciMove
      };
      
      await executeRobotMove(moveData);
      
      setLastExecutedMove(move.uciMove);
      setText([
        'âœ… Robot move executed!',
        `Move: ${move.uciMove}`,
        move.isCapture ? 'Capture move completed' : 'Move completed'
      ]);
      
    } catch (error: any) {
      console.error('Move execution error:', error);
      setText(['âŒ Robot move failed:', error.message || 'Unknown error']);
    } finally {
      setExecutingMove(false);
    }
  };

  const handleColorSelect = (selectedColor: Color) => {
    setPlayerColor(selectedColor);
    
    const board = new Chess();
    const payload = makeUpdatePayload(board);
    dispatch(gameUpdate(payload));
    
    stockfishMoveRef.current = {};
    setLastExecutedMove('');
    
    setText([`Playing as ${selectedColor === 'w' ? 'White' : 'Black'}`, "vs Stockfish"]);
    
    if (selectedColor === 'b' && stockfishReady) {
      setTimeout(() => {
        applyStockfishMove();
      }, 500);
    }
  };
  
  const resetGame = () => {
    const board = new Chess();
    const payload = makeUpdatePayload(board);
    dispatch(gameUpdate(payload));
    
    stockfishMoveRef.current = {};
    setLastExecutedMove('');
    
    setText(["Game reset"]);
  };

  // Initialize Stockfish
  useEffect(() => {
    const initStockfish = async () => {
      try {
        const engine = stockfishEngineRef.current;
        const isReady = await engine.waitForReady();
        setStockfishReady(isReady);
      } catch (error) {
        console.error("Failed to initialize Stockfish:", error);
        setStockfishReady(false);
      }
    };
    
    initStockfish();
  }, []);
  
  return (
    <div className="d-flex flex-column">
      <Sidebar sidebarRef={sidebarRef} playing={playing} text={text} setText={setText} >
        <li className="my-1" style={{display: playing ? "none": "inline-block"}}>
          <DeviceButton videoRef={videoRef} onDeviceChange={onDeviceChange} />  {/* Added onDeviceChange */}
        </li>
        <li className="my-1" style={{display: playing ? "none": "inline-block"}}>
          <div className="dropdown">
            <button className="btn btn-dark btn-sm btn-outline-light dropdown-toggle w-100" 
              id="colorButton" data-bs-toggle="dropdown" aria-expanded="false">
              Playing as: {playerColor === 'w' ? 'White' : 'Black'}
              {!stockfishReady && " (Loading Stockfish...)"}
              {isStockfishThinking && " (Stockfish thinking...)"}
            </button>
            <ul className="dropdown-menu" aria-labelledby="colorButton">
              <li>
                <a className="dropdown-item" href="#" onClick={() => handleColorSelect('w')}>
                  White (Human) vs Black (Stockfish)
                </a>
              </li>
              <li>
                <a className="dropdown-item" href="#" onClick={() => handleColorSelect('b')}>
                  Black (Human) vs White (Stockfish)
                </a>
              </li>
            </ul>
          </div>
        </li>
        <li className="my-1" style={{display: playing ? "none": "inline-block"}}>
          <CornersButton piecesModelRef={piecesModelRef} xcornersModelRef={xcornersModelRef} videoRef={videoRef} canvasRef={canvasRef} 
          setText={setText} />
        </li>
        
        {/* Auto Mode Toggle */}
        <li className="my-1">
          <div className="form-check form-switch text-white">
            <input
              className="form-check-input"
              type="checkbox"
              id="autoModeToggle"
              checked={autoMode}
              onChange={(e) => setAutoMode(e.target.checked)}
              disabled={executingMove}
            />
            <label className="form-check-label" htmlFor="autoModeToggle">
              Auto Execute Robot Moves
            </label>
          </div>
        </li>
        
        {/* Execute Robot Move Button (only show when not in auto mode) */}
        {!autoMode && (
          <li className="my-1">
            <button 
              className="btn btn-dark btn-sm btn-outline-light w-100"
              onClick={handleExecuteRobotMove}
              disabled={executingMove || !stockfishMoveRef.current?.readyForExecution}
            >
              {executingMove ? (
                <>
                  <span className="spinner-border spinner-border-sm me-2" role="status"></span>
                  Executing...
                </>
              ) : 'Execute Robot Move'}
            </button>
          </li>
        )}
        
        {/* Clear Buffer Button for testing */}
        <li className="my-1">
          <button 
            className="btn btn-dark btn-sm btn-outline-secondary w-100"
            onClick={() => {
              if (stockfishMoveRef.current?.uciMove) {
                clearPieceBaseBuffer(stockfishMoveRef.current.uciMove);
                stockfishMoveRef.current.readyForExecution = false;
                setText(['Buffer cleared', 'Collecting new coordinates...']);
              }
            }}
            disabled={executingMove}
          >
            Clear Buffer
          </button>
        </li>
        
        <li className="my-1">
          <div className="btn-group w-100" role="group">
            <RecordButton playing={playing} setPlaying={setPlaying} />
            <button 
              className="btn btn-dark btn-sm btn-outline-light w-100"
              onClick={resetGame}
              disabled={executingMove}
            >
              Reset Game
            </button>
          </div>
        </li>
      </Sidebar>
      
      {/* Robot Control Section BELOW the Sidebar */}
      <div style={{minWidth: "200px", margin: "0 4px"}}>
        <RobotControl />
      </div>
    </div>
  );
};
  
export default PlaySidebar;

----- D:\chessweb\src\components\play\robotControl.tsx -----
import React, { useState, useEffect, useRef } from 'react';
import { getFullRobotPose, getSquareInfo } from '../../utils/transformPoses';

const ROBOT_CONFIG = {
  BRIDGE_URL: "ws://localhost:8765", // WebSocket bridge URL
};

interface RobotControlProps {
  onMove?: (squareNumber: number, squareName: string, x: number, y: number) => void;
}

const RobotControl: React.FC<RobotControlProps> = ({ onMove }) => {
  const [squareNumber, setSquareNumber] = useState<number>(11);
  const [squareInfo, setSquareInfo] = useState<any>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [connecting, setConnecting] = useState<boolean>(false);
  const [message, setMessage] = useState<string>('');
  const [robotConnected, setRobotConnected] = useState<boolean>(false);
  const [bridgeConnected, setBridgeConnected] = useState<boolean>(false);
  const [debugMessages, setDebugMessages] = useState<string[]>([]);
  
  const wsRef = useRef<WebSocket | null>(null);
  const reconnectAttemptRef = useRef<number>(0);
  const maxReconnectAttempts = 3;

  // Add debug logging
  const addDebugMessage = (msg: string) => {
    console.log(`[DEBUG RobotControl] ${msg}`);
    setDebugMessages(prev => [...prev.slice(-10), `${new Date().toLocaleTimeString()}: ${msg}`]);
  };

  // Initialize WebSocket connection
  useEffect(() => {
    const connectWebSocket = () => {
      addDebugMessage('Connecting to WebSocket bridge...');
      
      try {
        wsRef.current = new WebSocket(ROBOT_CONFIG.BRIDGE_URL);
        
        wsRef.current.onopen = () => {
          addDebugMessage('âœ… WebSocket connected to bridge');
          setBridgeConnected(true);
          reconnectAttemptRef.current = 0;
          
          // Send a test message to verify connection
          setTimeout(() => {
            sendBridgeCommand({ type: 'status' })
              .then(response => {
                if (response.type === 'status') {
                  addDebugMessage(`Bridge status: ${JSON.stringify(response.status)}`);
                }
              })
              .catch(err => {
                addDebugMessage(`Status check failed: ${err.message}`);
              });
          }, 1000);
        };
        
        wsRef.current.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            addDebugMessage(`â† FROM BRIDGE: ${JSON.stringify(data)}`);
            
            // Handle different response types
            if (data.type === 'connected') {
              setRobotConnected(true);
              setMessage('âœ… Robot system connected successfully!');
              addDebugMessage('Robot system is now connected');
            } else if (data.type === 'error') {
              setMessage(`âŒ ${data.message}`);
              addDebugMessage(`Error from bridge: ${data.message}`);
            } else if (data.type === 'status') {
              addDebugMessage(`Robot status: ${JSON.stringify(data.status)}`);
              if (data.status?.connected) {
                setRobotConnected(true);
              }
            } else if (data.type === 'move_complete') {
              addDebugMessage(`Move completed: ${data.message}`);
            } else if (data.type === 'gripper_complete') {
              addDebugMessage(`Gripper action completed: ${data.message}`);
            }
          } catch (error) {
            addDebugMessage(`Failed to parse message: ${event.data}`);
          }
        };
        
        wsRef.current.onerror = (error) => {
          addDebugMessage(`WebSocket error: ${error.type}`);
          setBridgeConnected(false);
        };
        
        wsRef.current.onclose = (event) => {
          addDebugMessage(`WebSocket closed: ${event.code} ${event.reason}`);
          setBridgeConnected(false);
          setRobotConnected(false);
          
          // Attempt reconnect
          if (reconnectAttemptRef.current < maxReconnectAttempts) {
            reconnectAttemptRef.current += 1;
            addDebugMessage(`Attempting reconnect ${reconnectAttemptRef.current}/${maxReconnectAttempts}...`);
            setTimeout(connectWebSocket, 2000);
          }
        };
        
      } catch (error: any) {
        addDebugMessage(`Failed to create WebSocket: ${error.message}`);
        setBridgeConnected(false);
      }
    };
    
    connectWebSocket();
    
    // Cleanup on unmount
    return () => {
      if (wsRef.current) {
        wsRef.current.close();
        wsRef.current = null;
      }
    };
  }, []);

  const updateSquareInfo = (number: number) => {
    const info = getSquareInfo(number);
    setSquareInfo(info);
    return info;
  };

  useEffect(() => {
    updateSquareInfo(squareNumber);
  }, [squareNumber]);

  const handleNumberChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = parseInt(e.target.value);
    if (value >= 1 && value <= 64) {
      setSquareNumber(value);
      updateSquareInfo(value);
    }
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    moveToSquare(squareNumber);
  };

  // Generic function to send commands to bridge
  const sendBridgeCommand = (command: any, timeout = 5000): Promise<any> => {
    return new Promise((resolve, reject) => {
      if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) {
        reject(new Error('WebSocket not connected'));
        return;
      }
      
      const messageId = Date.now();
      const commandWithId = { ...command, id: messageId };
      
      addDebugMessage(`â†’ TO BRIDGE: ${JSON.stringify(command)}`);
      
      // Set up one-time message handler
      const handleMessage = (event: MessageEvent) => {
        try {
          const data = JSON.parse(event.data);
          // Check if this response corresponds to our command
          if (data.id === messageId || !data.id) {
            wsRef.current?.removeEventListener('message', handleMessage);
            clearTimeout(timeoutId);
            resolve(data);
          }
        } catch (error) {
          // Not JSON, ignore
        }
      };
      
      const timeoutId = setTimeout(() => {
        wsRef.current?.removeEventListener('message', handleMessage);
        reject(new Error('Bridge response timeout'));
      }, timeout);
      
      wsRef.current.addEventListener('message', handleMessage);
      wsRef.current.send(JSON.stringify(commandWithId));
    });
  };

  // Connect to robot system
  const connectToRobot = async () => {
    setConnecting(true);
    setMessage('Connecting to robot system...');
    addDebugMessage('Attempting to connect robot system...');
    
    try {
      const response = await sendBridgeCommand({ type: 'connect' });
      
      if (response.type === 'connected') {
        setRobotConnected(true);
        setMessage('âœ… Robot system connected!');
      } else if (response.type === 'error') {
        setMessage(`âŒ Failed to connect: ${response.message}`);
        addDebugMessage(`Connection error: ${response.message}`);
      }
    } catch (error: any) {
      setMessage(`âŒ Connection failed: ${error.message}`);
      addDebugMessage(`Connection exception: ${error.message}`);
    } finally {
      setConnecting(false);
    }
  };

  // Disconnect from robot system
  const disconnectFromRobot = async () => {
    setMessage('Disconnecting from robot system...');
    addDebugMessage('Sending disconnect command...');
    
    try {
      await sendBridgeCommand({ type: 'disconnect' });
      setRobotConnected(false);
      setMessage('âœ… Robot system disconnected');
    } catch (error: any) {
      setMessage(`âš ï¸ ${error.message}`);
    }
  };

  // Test robot system
  const testRobotConnection = async () => {
    setMessage('Testing robot connection...');
    addDebugMessage('Sending test command...');
    
    try {
      const response = await sendBridgeCommand({ type: 'test', test: 'Hello Bridge!' });
      if (response.type === 'test_response') {
        setMessage(`âœ… Bridge test successful: ${response.message}`);
      }
    } catch (error: any) {
      setMessage(`âŒ Test failed: ${error.message}`);
    }
  };

  // Get robot status
  const getRobotStatus = async () => {
    setMessage('Getting robot status...');
    
    try {
      const response = await sendBridgeCommand({ type: 'status' });
      if (response.type === 'status') {
        const status = response.status;
        const armStatus = status?.arm?.connected ? 'âœ… Connected' : 'âŒ Disconnected';
        const gripperStatus = status?.gripper?.connected ? 'âœ… Connected' : 'âŒ Disconnected';
        setMessage(`Arm: ${armStatus}, Gripper: ${gripperStatus}`);
        addDebugMessage(`Full status: ${JSON.stringify(status)}`);
      }
    } catch (error: any) {
      setMessage(`âŒ Status check failed: ${error.message}`);
    }
  };

  const moveToSquare = async (number: number) => {
    setLoading(true);
    const moveMessage = `Moving to square ${number}...`;
    setMessage(moveMessage);
    addDebugMessage(moveMessage);

    // Get square info
    const info = updateSquareInfo(number);
    if (!info) {
      const errMsg = `Square ${number} information not available.`;
      setMessage(errMsg);
      addDebugMessage(errMsg);
      setLoading(false);
      return;
    }

    if (!info.robotX || !info.robotY) {
      const errMsg = `Square ${number} robot coordinates not available. Click "Play" to calibrate first!`;
      setMessage(errMsg);
      addDebugMessage(errMsg);
      setLoading(false);
      return;
    }

    // Get full robot pose (includes Z and rotation from JSON)
    const fullPose = getFullRobotPose(number);
    
    if (!fullPose) {
      const errMsg = [
        `âŒ Cannot move: Calibration not complete!`,
        `1. Click "Play" button in the main interface`,
        `2. Wait for "Corner centers logged" message in console`,
        `3. Make sure chessboard_poses.json exists in public folder`,
        `4. Try moving to square ${number} again`
      ].join('\n');
      setMessage(errMsg);
      addDebugMessage('Calibration not complete');
      setLoading(false);
      return;
    }

    // Use the calibrated pose from JSON
    const pose = {
      x: fullPose.x,
      y: fullPose.y,
      z: fullPose.z,    // Uses actual Z from JSON calibration
      rx: fullPose.rx,  // Uses actual rotation from JSON
      ry: fullPose.ry,
      rz: fullPose.rz
    };

    addDebugMessage(`Sending move command: ${JSON.stringify(pose)}`);
    
    try {
      const response = await sendBridgeCommand({
        type: 'move',
        pose: pose,
        moveType: 'clearance'
      }, 10000); // Longer timeout for move commands
      
      if (response.type === 'move_complete') {
        const successMessage = `âœ… Move to ${info.squareName} completed! (X:${pose.x.toFixed(4)}, Y:${pose.y.toFixed(4)}, Z:${pose.z.toFixed(4)})`;
        setMessage(successMessage);
        addDebugMessage(successMessage);
        
        if (onMove) {
          onMove(number, info.squareName, pose.x, pose.y);
        }
      } else if (response.type === 'error') {
        const errorMessage = `âŒ Move failed: ${response.message}`;
        setMessage(errorMessage);
        addDebugMessage(errorMessage);
      }
    } catch (error: any) {
      const errorMessage = `âŒ Move command failed: ${error.message}`;
      setMessage(errorMessage);
      addDebugMessage(errorMessage);
      
      // Fallback to simulation mode if bridge fails
      if (error.message.includes('timeout') || error.message.includes('not connected')) {
        const fallbackMessage = `BRIDGE OFFLINE - Would move to ${info.squareName} (X:${pose.x.toFixed(4)}, Y:${pose.y.toFixed(4)}, Z:${pose.z.toFixed(4)})`;
        setMessage(fallbackMessage);
        
        if (onMove) {
          onMove(number, info.squareName, pose.x, pose.y);
        }
      }
    } finally {
      setLoading(false);
    }
  };

  // Check if calibration is available to determine button state
  const isCalibrationAvailable = squareInfo?.fullPose !== undefined;
  const isRobotReady = squareInfo?.robotX && squareInfo?.robotY && isCalibrationAvailable && robotConnected;

  return (
    <div className="text-white">
      <h6 className="border-bottom pb-2 mb-2">Robot Control</h6>
      
      {/* Connection Status */}
      <div className="mb-3">
        <div className="d-flex justify-content-between align-items-center mb-2">
          <div>
            <small>Bridge: 
              <span className={bridgeConnected ? "text-success ms-2" : "text-danger ms-2"}>
                {bridgeConnected ? 'âœ… Connected' : 'âŒ Disconnected'}
              </span>
            </small>
          </div>
          <div>
            <small>Robot: 
              <span className={robotConnected ? "text-success ms-2" : "text-danger ms-2"}>
                {robotConnected ? 'âœ… Connected' : 'âŒ Disconnected'}
              </span>
            </small>
          </div>
        </div>
        
        {/* Connection Controls */}
        <div className="btn-group w-100 mb-2" role="group">
          <button 
            className="btn btn-success btn-sm"
            onClick={connectToRobot}
            disabled={connecting || !bridgeConnected || robotConnected}
          >
            {connecting ? (
              <>
                <span className="spinner-border spinner-border-sm me-2" role="status"></span>
                Connecting...
              </>
            ) : 'Connect Robot'}
          </button>
          <button 
            className="btn btn-warning btn-sm"
            onClick={disconnectFromRobot}
            disabled={!robotConnected}
          >
            Disconnect
          </button>
        </div>
        
        {/* Test and Status Buttons */}
        <div className="btn-group w-100 mb-3" role="group">
          <button 
            className="btn btn-info btn-sm"
            onClick={testRobotConnection}
            disabled={!bridgeConnected}
          >
            Test Bridge
          </button>
          <button 
            className="btn btn-secondary btn-sm"
            onClick={getRobotStatus}
            disabled={!bridgeConnected}
          >
            Get Status
          </button>
        </div>
      </div>
      
      {/* Square Movement Controls */}
      <form onSubmit={handleSubmit} className="mb-3">
        <div className="input-group input-group-sm mb-2">
          <span className="input-group-text">Square (1-64)</span>
          <input
            type="number"
            className="form-control"
            value={squareNumber}
            onChange={handleNumberChange}
            min="1"
            max="64"
            disabled={loading || !robotConnected}
          />
          <button 
            type="submit" 
            className="btn btn-primary btn-sm"
            disabled={loading || !isRobotReady || !robotConnected}
          >
            {loading ? (
              <>
                <span className="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span>
                Moving...
              </>
            ) : 'Move Robot'}
          </button>
        </div>
        
        <small className={`d-block mb-2 ${robotConnected ? 'text-success' : 'text-warning'}`}>
          {robotConnected 
            ? 'âœ… Robot is connected and ready for movement'
            : 'âš ï¸ Connect the robot system first to enable movement'
          }
        </small>
      </form>
      
      {/* Square Info */}
      {squareInfo && (
        <div className="mb-3">
          <div><small>Square: <strong>{squareInfo.squareName}</strong></small></div>
          <div><small>Robot X: <code>{squareInfo.robotX?.toFixed(4) || 'N/A'}</code></small></div>
          <div><small>Robot Y: <code>{squareInfo.robotY?.toFixed(4) || 'N/A'}</code></small></div>
          <div><small>Robot Z: <code>{squareInfo.fullPose?.z?.toFixed(4) || 'N/A'}</code></small></div>
          <div><small>Camera X: <code>{squareInfo.cameraX?.toFixed(0) || 'N/A'}</code></small></div>
          <div><small>Camera Y: <code>{squareInfo.cameraY?.toFixed(0) || 'N/A'}</code></small></div>
          <div className={`small ${isCalibrationAvailable ? 'text-success' : 'text-warning'}`}>
            <strong>Calibration:</strong> {isCalibrationAvailable ? 'âœ… Available' : 'âš ï¸ Required'}
          </div>
        </div>
      )}
      
      {/* Status Message */}
      <div className="alert alert-sm p-2 mb-2" style={{
        backgroundColor: message.includes('âŒ') ? '#f8d7da' : 
                        message.includes('âš ï¸') ? '#fff3cd' : '#d1ecf1',
        color: message.includes('âŒ') ? '#721c24' : 
               message.includes('âš ï¸') ? '#856404' : '#0c5460'
      }}>
        <small>
          <strong>Status:</strong> {message}
        </small>
      </div>
      
      {/* Debug Panel (Collapsible) */}
      <details className="small text-muted mb-3">
        <summary>Debug Info (Last 10 messages)</summary>
        <div className="mt-2 p-2 bg-dark border rounded" style={{maxHeight: '150px', overflowY: 'auto'}}>
          {debugMessages.length > 0 ? (
            debugMessages.map((msg, idx) => (
              <div key={idx} className="font-monospace small">
                {msg}
              </div>
            ))
          ) : (
            <div>No debug messages yet</div>
          )}
        </div>
      </details>
      
      <div className="small text-muted">
        <strong>Setup Instructions:</strong>
        <ol className="mt-1 mb-2" style={{fontSize: '0.75rem'}}>
          <li>Start robot bridge: <code>python robot_bridge_advanced.py</code></li>
          <li>Click "Play" in main interface to calibrate corners</li>
          <li>Click "Connect Robot" button above</li>
          <li>Select square number and click "Move Robot"</li>
        </ol>
        
        <strong>Troubleshooting:</strong>
        <ul style={{fontSize: '0.75rem'}}>
          <li>Check bridge is running (should show listening on ws://localhost:8765)</li>
          <li>Ensure UR5 and gripper are powered on</li>
          <li>Verify network connectivity to 192.168.1.20 (UR5) and 192.168.1.1 (gripper)</li>
        </ul>
        
        <strong>Square Mapping:</strong>
        <div className="row">
          <div className="col-6">
            1=A1, 2=B1, 3=C1<br/>
            9=A2, 10=B2, 11=C2<br/>
            57=A8, 58=B8, 59=C8
          </div>
          <div className="col-6">
            ... 8=H1<br/>
            ... 16=H2<br/>
            ... 64=H8
          </div>
        </div>
      </div>
    </div>
  );
};

export default RobotControl;

----- D:\chessweb\src\components\record\recordSidebar.tsx -----
import { CornersButton, Sidebar, RecordButton, StopButton, FenButton, DeviceButton } from "../common";
import { SetBoolean, SetStringArray, CameraDevice } from "../../types";

const RecordSidebar = ({ piecesModelRef, xcornersModelRef, videoRef, canvasRef, sidebarRef, 
  playing, setPlaying, text, setText, cornersRef, onDeviceChange }: {  // Added onDeviceChange
  piecesModelRef: any, xcornersModelRef: any, videoRef: any, canvasRef: any, sidebarRef: any,
  playing: boolean, setPlaying: SetBoolean, 
  text: string[], setText: SetStringArray,
  cornersRef: any,
  onDeviceChange?: (device: CameraDevice) => void  // Added
}) => {
  const inputStyle = {
    display: playing ? "none": "inline-block"
  }
  return (
    <Sidebar sidebarRef={sidebarRef} playing={playing} text={text} setText={setText} >
      <li className="my-1" style={inputStyle}>
        <DeviceButton videoRef={videoRef} onDeviceChange={onDeviceChange} />  {/* Added onDeviceChange */}
      </li>
      <li className="my-1" style={inputStyle}>
        <CornersButton piecesModelRef={piecesModelRef} xcornersModelRef={xcornersModelRef} videoRef={videoRef} canvasRef={canvasRef} 
        setText={setText} />
      </li>
      <li className="my-1" style={inputStyle}>
        <FenButton piecesModelRef={piecesModelRef} videoRef={videoRef} 
        canvasRef={canvasRef} setText={setText} cornersRef={cornersRef} />
      </li>
      <li className="my-1">
        <div className="btn-group w-100" role="group">
          <RecordButton playing={playing} setPlaying={setPlaying} />
          <StopButton setPlaying={setPlaying} setText={setText} />
        </div>
      </li>
    </Sidebar>
  );
};

export default RecordSidebar;

----- D:\chessweb\src\components\test\TestStockfish.tsx -----
import { useEffect, useState } from 'react';
import { getStockfishEngine } from '../../utils/stockfish';

const TestStockfish = () => {
  const [message, setMessage] = useState('Loading Stockfish...');
  const [engine, setEngine] = useState<any>(null);
  
  useEffect(() => {
    const init = async () => {
      const sfEngine = getStockfishEngine();
      setEngine(sfEngine);
      
      // Wait a bit for initialization
      setTimeout(async () => {
        try {
          const result = await sfEngine.analyzePosition(
            'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1',
            12
          );
          
          if (result.evaluation !== undefined) {
            setMessage(`Stockfish working! Eval: ${result.evaluation > 0 ? '+' : ''}${result.evaluation.toFixed(2)}`);
          } else if (result.mateIn !== undefined) {
            setMessage(`Stockfish working! Mate in ${Math.abs(result.mateIn)}`);
          } else {
            setMessage('Stockfish loaded but no eval received');
          }
        } catch (error) {
          setMessage('Error testing Stockfish: ' + error);
        }
      }, 2000);
    };
    
    init();
  }, []);
  
  const testMove = async () => {
    if (engine) {
      setMessage('Calculating move...');
      const move = await engine.getBestMove(
        'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1',
        1000
      );
      setMessage(`Best move: ${move || 'No move found'}`);
    }
  };
  
  return (
    <div style={{ padding: '20px', color: 'white', backgroundColor: '#333', height: '100vh' }}>
      <h2>Stockfish Test</h2>
      <p>{message}</p>
      <button 
        onClick={testMove}
        style={{ 
          padding: '10px 20px', 
          backgroundColor: '#007bff', 
          color: 'white', 
          border: 'none', 
          borderRadius: '5px',
          marginRight: '10px'
        }}
      >
        Test Stockfish Move
      </button>
      <button 
        onClick={() => window.location.href = '/'}
        style={{ 
          padding: '10px 20px', 
          backgroundColor: '#6c757d', 
          color: 'white', 
          border: 'none', 
          borderRadius: '5px' 
        }}
      >
        Back to Home
      </button>
    </div>
  );
};

export default TestStockfish;

----- D:\chessweb\src\components\upload\uploadSidebar.tsx -----
import { VideoButton, PlayButton, RestartButton, PlaybackButtons, StopButton } from "./buttons";
import { CornersButton, Sidebar, FenButton, DeviceButton } from "../common";
import { SetBoolean, SetStringArray, CameraDevice } from "../../types";

const UploadSidebar = ({ videoRef, xcornersModelRef, piecesModelRef, canvasRef, 
  sidebarRef, text, setText, playing, setPlaying, cornersRef, onDeviceChange }: {  // Added onDeviceChange
  videoRef: any, xcornersModelRef: any, piecesModelRef: any, canvasRef: any, sidebarRef: any,
  text: string[], setText: SetStringArray,
  playing: boolean, setPlaying: SetBoolean,
  cornersRef: any,
  onDeviceChange?: (device: CameraDevice) => void  // Added
}) => {

  const inputStyle = {
    display: playing ? "none": "inline-block"
  }

  return (
    <Sidebar sidebarRef={sidebarRef} playing={playing} text={text} setText={setText} >
      {/* Note: Upload mode typically uses uploaded video files, not live camera.
          But we include DeviceButton for consistency, though it won't be used in upload mode. */}
      <li className="my-1" style={inputStyle}>
        <DeviceButton videoRef={videoRef} onDeviceChange={onDeviceChange} />
      </li>
      <li className="my-1" style={inputStyle}>
        <VideoButton videoRef={videoRef} canvasRef={canvasRef} setPlaying={setPlaying} />
      </li>
      <li className="my-1" style={inputStyle}>
        <CornersButton piecesModelRef={piecesModelRef} xcornersModelRef={xcornersModelRef} 
        videoRef={videoRef} canvasRef={canvasRef} setText={setText} />
      </li>
      <li className="my-1" style={inputStyle}>
        <FenButton piecesModelRef={piecesModelRef} videoRef={videoRef} 
        canvasRef={canvasRef} setText={setText} cornersRef={cornersRef} />
      </li>
      <li className="my-1" style={inputStyle}>
        <PlaybackButtons videoRef={videoRef} />
      </li>
      <li className="my-1">
        <div className="btn-group w-100" role="group">
          <PlayButton videoRef={videoRef} playing={playing} setPlaying={setPlaying} />
          <StopButton videoRef={videoRef} setPlaying={setPlaying} setText={setText} />
          <RestartButton videoRef={videoRef} setText={setText} />
        </div>
      </li>
    </Sidebar>
  );
};

export default UploadSidebar;

----- D:\chessweb\src\components\upload\buttons\index.tsx -----
import PlayButton from "./playButton";
import RestartButton from "./restartButton";
import VideoButton from "./videoButton";
import PlaybackButtons from "./playbackButtons";
import StopButton from "./stopButton";

export { PlayButton, RestartButton, VideoButton, PlaybackButtons, StopButton };

----- D:\chessweb\src\components\upload\buttons\playbackButtons.tsx -----
const PlayButton = ({ videoRef }: { videoRef: any }) => {
  const PlaybackButton = ({ playbackRate}: { playbackRate: number } ) => {
    const handleClick = (e: any) => {
      e.preventDefault();
      videoRef.current.playbackRate = playbackRate 
    }
    
    return (
      <button 
        type="button" 
        className="btn btn-secondary btn-dark btn-outline-light w-100"
        onClick={handleClick}
      >
      {playbackRate}x
      </button>
    )
  }

  return (
    <div className="btn-group w-100" role="group">
      <PlaybackButton playbackRate={1} />
      <PlaybackButton playbackRate={2} /> 
      <PlaybackButton playbackRate={4} />
    </div>
  );
};

export default PlayButton;


----- D:\chessweb\src\components\upload\buttons\playButton.tsx -----
import { SetBoolean } from "../../../types";
import { SidebarButton, Icon } from "../../common";

const PlayButton = ({ videoRef, playing, setPlaying }: {
  videoRef: any, playing: boolean, setPlaying: SetBoolean
}) => {
  const handleClick = (e: any) => {
    e.preventDefault();
    
    if (videoRef.current.src.startsWith("blob")) {
      setPlaying(!playing);
    }
  }

 return (
    <SidebarButton onClick={handleClick}>
      <Icon iconName={playing ? "bi-pause" : "bi-play"} />
    </SidebarButton>
  );
};

export default PlayButton;


----- D:\chessweb\src\components\upload\buttons\restartButton.tsx -----
import { useDispatch } from "react-redux";
import { gameResetFen, gameResetMoves } from "../../../slices/gameSlice";
import { SidebarButton, Icon } from "../../common";
import { SetStringArray } from "../../../types";

const RestartButton = ({ videoRef, setText }: { videoRef: any, setText: SetStringArray}) => {
  const dispatch = useDispatch();
  
  const handleClick = (e: any) => {
    e.preventDefault();

    videoRef.current.currentTime = 0;
    dispatch(gameResetMoves());
    dispatch(gameResetFen());
    setText(["Rewound video", "Reset PGN to start position"])
  }

 return (
    <SidebarButton onClick={handleClick}>
      <Icon iconName="bi-skip-start" />
    </SidebarButton>
  );
};

export default RestartButton;


----- D:\chessweb\src\components\upload\buttons\stopButton.tsx -----
import { useDispatch } from "react-redux";
import { gameResetFen, gameResetMoves } from "../../../slices/gameSlice";
import { SidebarButton, Icon } from "../../common";
import { SetBoolean, SetStringArray } from "../../../types";

const StopButton = ({ videoRef, setPlaying, setText }: {
  videoRef: any, setPlaying: SetBoolean, setText: SetStringArray
}) => {
  const dispatch = useDispatch();

  const handleClick = (e: any) => {
    e.preventDefault();
    
    if (videoRef.current.src.startsWith("blob")) {
      setPlaying(false);
      dispatch(gameResetMoves());
      dispatch(gameResetFen());
      setText(["Reset to start position"])
    }
  }

 return (
    <SidebarButton onClick={handleClick}>
      <Icon iconName="bi-stop" />
    </SidebarButton>
  );
};

export default StopButton;


----- D:\chessweb\src\components\upload\buttons\videoButton.tsx -----
import { useRef, useState } from "react";
import { clearCtx } from "../../../utils/render/common";
import { Icon, SidebarButton } from "../../common";
import { SetBoolean } from "../../../types";

const VideoButton = ({ videoRef, canvasRef, setPlaying }: {
  videoRef: any, canvasRef: any, setPlaying: SetBoolean
}) => {
  const inputVideoRef: any = useRef(null);
  const [streaming, setStreaming] = useState(false);

  const closeVideo = () => {
    if (videoRef.current.src !== undefined) {
      const url = videoRef.current.src;
      videoRef.current.src = "";
      URL.revokeObjectURL(url);
    }

    clearCtx(canvasRef.current.getContext('2d'));

    setStreaming(false);
    inputVideoRef.current.value = "";
    videoRef.current.style.display = "none";
  };

  const handleOnChange = (e: any) => {
    const url = URL.createObjectURL(e.target.files[0]); 
    videoRef.current.src = url;
    videoRef.current.style.display = "block";
    setStreaming(true);
  }

  const handleOnClick = () => {
    if (streaming === false) {
      inputVideoRef.current.click();
    } else {
      closeVideo();
    }
    setPlaying(false);
  }

  return (
    <>
      <input
        type="file"
        accept="video/*"
        style={{ display: "none" }}
        onChange={handleOnChange}
        ref={inputVideoRef}
      />
      <SidebarButton onClick={handleOnClick}>
        <Icon iconName={streaming ? "bi-folder-x" : "bi-folder"} />
      </SidebarButton>
    </>
  );
};

export default VideoButton;



----- D:\chessweb\src\slices\cornersSlice.tsx -----
import { createSlice } from '@reduxjs/toolkit';
import { CornersDict, CornersPayload, RootState } from "../types";
import { useSelector } from 'react-redux';

const initialState: CornersDict = {"h1": [50, -100], "a1": [0, -100], "a8": [0, -150], "h8": [50, -150]}

interface Action {
  payload: CornersPayload,
  type: string
}

const cornersSlice = createSlice({
  name: 'corners',
  initialState,
  reducers: {
    cornersSet(state, action: Action) {
      state[action.payload.key] = action.payload.xy;
    },
    cornersReset() {
      return initialState
    }
  }
})

export const cornersSelect = () => {
  return useSelector((state: RootState) => state.corners)
}

export const { cornersSet, cornersReset } = cornersSlice.actions
export default cornersSlice.reducer

----- D:\chessweb\src\slices\gameSlice.tsx -----
import { createSlice } from '@reduxjs/toolkit'
import { useSelector } from 'react-redux';
import { Game, RootState } from '../types';
import { START_FEN } from '../utils/constants';
import { Chess } from 'chess.js';

const initialState: Game = {
  "moves": "",
  "fen": START_FEN,
  "start": START_FEN,
  "lastMove": "",
  "greedy": false
};

const gameSlice = createSlice({
  name: 'game',
  initialState,
  reducers: {
    gameSetMoves(state, action) {
      state.moves = action.payload
    },
    gameSetFen(state, action) {
      state.fen = action.payload;
    },
    gameSetStart(state, action) {
      state.start = action.payload;
    },
    gameSetLastMove(state, action) {
      state.lastMove = action.payload;
    },
    gameResetMoves(state) {
      state.moves = initialState.moves;
    },
    gameResetFen(state) {
      state.fen = initialState.fen;
    },
    gameResetStart(state) {
      state.start = initialState.start;
    },
    gameResetLastMove(state) {
      state.lastMove = initialState.lastMove;
    },
    gameUpdate(state, action) {
      const newState: Game = {
        "start": state.start,
        "moves": action.payload.moves,
        "fen": action.payload.fen,
        "lastMove": action.payload.lastMove,
        "greedy": action.payload.greedy
      }
      return newState
    }
  }
})

const getMovesFromPgn = (board: Chess) => {
  const pgn = board.pgn();

  // Get rid of the headers (strings beginning with "[" and ending with "]")
  // Get rid of newline characters
  const moves = pgn.replace(/\[.*?\]/g, '').replace(/\r?\n|\r/g, '');
  return moves
}

export const gameSelect = () => {
  return useSelector((state: RootState) => state.game)
}

export const makePgn = (game: Game) => {
  return `[FEN "${game.start}"]` + "\n \n" + game.moves;
}

export const makeUpdatePayload = (board: Chess, greedy: boolean=false) => {
  const history = board.history({ "verbose": true });

  const moves = getMovesFromPgn(board);
  const fen = board.fen();
  const lastMove = (history.length === 0) ? "" : history[history.length - 1].lan;

  const payload = {
    "moves": moves,
    "fen": fen,
    "lastMove": lastMove,
    "greedy": greedy
  }

  return payload
}

export const makeBoard = (game: Game): Chess => {
  const board = new Chess(game.start);
  board.loadPgn(makePgn(game));
  return board;
}

export const { 
  gameSetMoves, gameResetMoves,
  gameSetFen, gameResetFen, 
  gameSetStart, gameResetStart,
  gameSetLastMove, gameResetLastMove, gameUpdate
} = gameSlice.actions
export default gameSlice.reducer

----- D:\chessweb\src\slices\index.tsx -----
import cornersReducer from "./cornersSlice";
import gameReducer from "./gameSlice";
import userReducer from "./userSlice";

export { cornersReducer, gameReducer, userReducer };

----- D:\chessweb\src\slices\userSlice.tsx -----
import { createSlice } from '@reduxjs/toolkit'
import { useSelector } from 'react-redux';
import { RootState } from '../types';

const initialState = {
  "username": "Player"  // Removed token field
};

const userSlice = createSlice({
  name: 'user',
  initialState,
  reducers: {
    userSetUsername(state, action) {
      state.username = action.payload
    },
    userReset() {
      return initialState
    }
  }
})

export const userSelect = () => {
  return useSelector((state: RootState) => state.user)
}

export const { userSetUsername, userReset } = userSlice.actions
export default userSlice.reducer

----- D:\chessweb\src\style\index.css -----
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html, body {
  width: 100%;
  height: 100%;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Oxygen", "Ubuntu",
    "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

#root {
  width: 100%;
  height: 100%;
}


----- D:\chessweb\src\utils\constants.tsx -----
import { PieceSymbol, Square } from "chess.js";
import { CornersKey } from "../types";

export const START_FEN: string = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
export const MODEL_WIDTH: number = 480;
export const MODEL_HEIGHT: number = 288;
export const MARKER_RADIUS: number = 25;
export const MARKER_DIAMETER: number = 2 * MARKER_RADIUS;
export const LABELS: string[] = ["b", "k", "n", "p", "q", "r", "B", "K", "N", "P", "Q", "R"];
export const PIECE_SYMBOLS: PieceSymbol[] = ["b", "k", "n", "p", "q", "r"];
export const SQUARE_NAMES: Square[] = ['a1', 'b1', 'c1', 'd1', 'e1', 'f1', 'g1', 'h1',
'a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2',
'a3', 'b3', 'c3', 'd3', 'e3', 'f3', 'g3', 'h3',
'a4', 'b4', 'c4', 'd4', 'e4', 'f4', 'g4', 'h4',
'a5', 'b5', 'c5', 'd5', 'e5', 'f5', 'g5', 'h5',
'a6', 'b6', 'c6', 'd6', 'e6', 'f6', 'g6', 'h6',
'a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7',
'a8', 'b8', 'c8', 'd8', 'e8', 'f8', 'g8', 'h8'];
export const SQUARE_SIZE: number = 128;
export const BOARD_SIZE: number = 8 * SQUARE_SIZE;
export const CORNER_KEYS: CornersKey[] = ["h1", "a1", "a8", "h8"];

const makeLabelMap = () => {
  const d: { [id: string]: number } = {};
  LABELS.forEach((label, i) => {
    d[label] = i;
  })
  return d;
}
export const LABEL_MAP: { [id: string]: number } = makeLabelMap();

const makeSquareMap = () => {
  const d: { [id: string]: number } = {};
  SQUARE_NAMES.forEach((square, i) => {
    d[square] = i;
  })
  return d;
}
export const SQUARE_MAP: { [id: string]: number } = makeSquareMap();

export const PALETTE: string[] = [
  "#FF3838",
  "#FF9D97",
  "#FF701F",
  "#FFB21D",
  "#CFD231",
  "#48F90A",
  "#92CC17",
  "#3DDB86",
  "#1A9334",
  "#00D4BB",
  "#2C99A8",
  "#00C2FF",
];

export const MEDIA_ASPECT_RATIO: number = 16 / 9;
export const MEDIA_CONSTRAINTS: any = {
  "audio": false,
  "video": {
    "facingMode": {
      "ideal": "environment"
    },
    "width": {
      "ideal": 640
    },
    "aspectRatio": MEDIA_ASPECT_RATIO,
    "resizeMode": "none"
  }
}

----- D:\chessweb\src\utils\detect.tsx -----
import { MODEL_WIDTH, MODEL_HEIGHT, MARKER_DIAMETER } from "./constants";
import * as tf from "@tensorflow/tfjs-core";
import { DeviceType } from "../types";

export const invalidVideo = (videoRef: any, deviceType: DeviceType = 'webcam') => {
  if (deviceType === 'droidcam') {
    // For DroidCam, we don't need to check srcObject, just check if ref exists
    return videoRef.current === null;
  }
  
  if (videoRef.current === null) {
    return true;
  }

  if (videoRef.current.autoplay) {
    // Record check
    if (videoRef.current?.srcObject === null) {
      return true;
    }
  } else {
    // Upload check
    const src = videoRef.current?.src;
    if (src === null) {
      return true;
    }

    if (!(src.startsWith("blob"))) {
      return true;
    }
  }

  return false;
}

export const getBbox = (points: number[][]) => {
  const xs: number[] = points.map(p => p[0]);
  const ys: number[] = points.map(p => p[1]);
  const xmin: number = Math.min(...xs);
  const xmax: number = Math.max(...xs);
  const ymin: number = Math.min(...ys);
  const ymax: number = Math.max(...ys);

  const width: number = xmax - xmin;
  const height: number = ymax - ymin;

  const bbox: any = {
    "xmin": xmin,
    "xmax": xmax,
    "ymin": ymin,
    "ymax": ymax,
    "width": width,
    "height": height
  }

  return bbox
}

export const getInput = (videoRef: any, keypoints: number[][] | null=null, paddingRatio: number=12, deviceType: DeviceType = 'webcam', droidcamImgRef?: any): {
  image4D: tf.Tensor4D, width: number, height: number, padding: number[], roi: number[]
} => {
  let roi: number[];
  let videoWidth: number, videoHeight: number;
  
  if (deviceType === 'droidcam' && droidcamImgRef?.current?.firstChild) {
    // Use the DroidCam image element
    const imgElement = droidcamImgRef.current.firstChild;
    videoWidth = imgElement.naturalWidth || imgElement.width;
    videoHeight = imgElement.naturalHeight || imgElement.height;
  } else {
    // Use the webcam video element
    videoWidth = videoRef.current.videoWidth;
    videoHeight = videoRef.current.videoHeight;
  }
  
  if (keypoints !== null) {
    const bbox = getBbox(keypoints);
    let paddingLeft: number = Math.floor(bbox.width / paddingRatio);
    let paddingRight: number = Math.floor(bbox.width / paddingRatio);
    let paddingTop: number = Math.floor(bbox.height / paddingRatio);
    const paddingBottom: number = Math.floor(bbox.height / paddingRatio)

    const paddedRoiWidth: number = bbox.width + paddingLeft + paddingRight;
    const paddedRoiHeight: number = bbox.height + paddingTop + paddingBottom;
    const ratio: number = paddedRoiHeight / paddedRoiWidth;
    const desiredRatio: number = MODEL_HEIGHT / MODEL_WIDTH;

    if (ratio > desiredRatio) {
        const targetWidth: number = paddedRoiHeight / desiredRatio;
        const dx: number = targetWidth - paddedRoiWidth;
        paddingLeft += Math.floor(dx / 2);
        paddingRight += dx - Math.floor(dx / 2);
    } else {
        const targetHeight: number = paddedRoiWidth * desiredRatio;
        paddingTop += targetHeight - paddedRoiHeight;
    }
    roi = [Math.round(Math.max(videoWidth * (bbox.xmin - paddingLeft) / MODEL_WIDTH, 0)),
      Math.round(Math.max(videoHeight * (bbox.ymin - paddingTop) / MODEL_HEIGHT, 0)),
      Math.round(Math.min(videoWidth * (bbox.xmax + paddingRight) / MODEL_WIDTH, videoWidth)),
      Math.round(Math.min(videoHeight * (bbox.ymax + paddingBottom) / MODEL_HEIGHT, videoHeight))]
  } else {
    roi = [0, 0, videoWidth, videoHeight];
  }
  const [image4D, width, height, padding]: [tf.Tensor4D, number, number, number[]] = tf.tidy(() => {
    let image: tf.Tensor3D;
    
    if (deviceType === 'droidcam' && droidcamImgRef?.current?.firstChild) {
      // Use DroidCam image
      image = tf.browser.fromPixels(droidcamImgRef.current.firstChild);
    } else {
      // Use webcam video
      image = tf.browser.fromPixels(videoRef.current);
    }
    
    // Cropping
    image = tf.slice(image,
      [roi[1], roi[0], 0], 
      [roi[3] - roi[1], roi[2] - roi[0], 3]
    );
    const height: number = image.shape[0];
    const width: number = image.shape[1];
    
    // Resizing
    const ratio: number = height / width;
    const desiredRatio: number = MODEL_HEIGHT / MODEL_WIDTH;
    let resizeHeight: number = MODEL_HEIGHT;
    let resizeWidth: number = MODEL_WIDTH;
    if (ratio > desiredRatio) {
      resizeWidth = Math.round(MODEL_HEIGHT / ratio); 
    } else {
      resizeHeight = Math.round(MODEL_WIDTH * ratio);
    }
    image = tf.image.resizeBilinear(image, [resizeHeight, resizeWidth]);

    // Padding
    const dx: number = MODEL_WIDTH - image.shape[1];
    const dy: number = MODEL_HEIGHT - image.shape[0];
    const padRight: number = Math.floor(dx / 2);
    const padLeft: number = dx - padRight
    const padBottom: number = Math.floor(dy / 2);
    const padTop: number = dy - padBottom;
    const padding: number[] = [padLeft, padRight, padTop, padBottom]
    image = tf.pad(image, [
      [padTop, padBottom],
      [padLeft, padRight],
      [0, 0]
    ], 114);
    
    // Transpose + scale + expand
    const image4D: tf.Tensor4D = tf.expandDims(tf.div(image, 255.0), 0);

    return [image4D, width, height, padding];
  });
  return {image4D, width, height, padding, roi}
};

export const getBoxesAndScores = (preds: tf.Tensor3D, width: number, height: number, 
  videoWidth: number, videoHeight: number, padding: number[], roi: number[]): {
    boxes: tf.Tensor2D, scores: tf.Tensor2D
  } => {
  const {boxes, scores} = tf.tidy(() => {
    const predsT: tf.Tensor3D = tf.transpose(preds, [0, 2, 1]);

    const w: tf.Tensor3D = tf.slice(predsT, [0, 0, 2], [-1, -1, 1]);
    const h: tf.Tensor3D = tf.slice(predsT, [0, 0, 3], [-1, -1, 1]);
    
    // xc, yc, w, h -> l, t, r, b
    let l: tf.Tensor2D = tf.sub(tf.slice(predsT, [0, 0, 0], [-1, -1, 1]), tf.div(w, 2));
    let t: tf.Tensor2D = tf.sub(tf.slice(predsT, [0, 0, 1], [-1, -1, 1]), tf.div(h, 2));
    let r: tf.Tensor2D = tf.add(l, w);
    let b: tf.Tensor2D = tf.add(t, h);
    
    // Remove padding
    l = tf.sub(l, padding[0]);
    r = tf.sub(r, padding[0]);
    t = tf.sub(t, padding[2]);
    b = tf.sub(b, padding[2]);

    // Scale
    l = tf.mul(l, width / (MODEL_WIDTH - padding[0] - padding[1]));
    r = tf.mul(r, width / (MODEL_WIDTH - padding[0] - padding[1]));
    t = tf.mul(t, height / (MODEL_HEIGHT - padding[2] - padding[3]));
    b = tf.mul(b, height / (MODEL_HEIGHT - padding[2] - padding[3]));

    // Add ROI
    l = tf.add(l, roi[0]);
    r = tf.add(r, roi[0]);
    t = tf.add(t, roi[1]);
    b = tf.add(b, roi[1]);

    // Scale
    l = tf.mul(l, MODEL_WIDTH / videoWidth);
    r = tf.mul(r, MODEL_WIDTH / videoWidth);
    t = tf.mul(t, MODEL_HEIGHT / videoHeight);
    b = tf.mul(b, MODEL_HEIGHT / videoHeight);

    const boxes: tf.Tensor2D = tf.squeeze(tf.concat([l, t, r, b], 2));
    const scores: tf.Tensor2D = tf.squeeze(tf.slice(predsT, [0, 0, 4], [-1, -1, predsT.shape[2] - 4]), [0]);

    return {boxes, scores};
  });
  return {boxes, scores};
} 

export const getCenters = (boxes: tf.Tensor2D) => {
  const centers: tf.Tensor2D = tf.tidy(() => {
    const l: tf.Tensor2D = tf.slice(boxes, [0, 0], [-1, 1]);
    const t: tf.Tensor2D = tf.slice(boxes, [0, 1], [-1, 1]);
    const r: tf.Tensor2D = tf.slice(boxes, [0, 2], [-1, 1]);
    const b: tf.Tensor2D = tf.slice(boxes, [0, 3], [-1, 1]);
    const cx: tf.Tensor2D = tf.div(tf.add(l, r), 2);
    const cy: tf.Tensor2D = tf.div(tf.add(t, b), 2);
    const centers: tf.Tensor2D = tf.concat([cx, cy], 1);
    return centers;
  })
  return centers;
}

export const getMarkerXY = (xy: number[], height: number, width: number) => {
  const sx: number = width / MODEL_WIDTH;
  const sy: number = height / MODEL_HEIGHT;
  const markerXY: number[] = [sx * xy[0], sy * xy[1] - height - MARKER_DIAMETER];
  return markerXY
}

export const getXY = (markerXY: number[], height: number, width: number) => {
  const sx: number = MODEL_WIDTH / width;
  const sy: number = MODEL_HEIGHT / height;
  const XY: number[] = [sx * markerXY[0], sy * (markerXY[1] + height + MARKER_DIAMETER)]
  return XY 
}

----- D:\chessweb\src\utils\findCorners.tsx -----
import * as tf from "@tensorflow/tfjs-core";
import { renderCorners } from "./render/renderCorners";
import Delaunator from 'delaunator';
import { getPerspectiveTransform, perspectiveTransform } from "./warp";
import { getBoxesAndScores, getInput, getCenters, getMarkerXY, invalidVideo } from "./detect";
import { cornersSet } from '../slices/cornersSlice';
import { MODEL_WIDTH, MODEL_HEIGHT, CORNER_KEYS } from "./constants";
import { clamp } from "./math";
import { CornersDict, CornersPayload } from "../types";
import { NDArray } from "vectorious";

const x: number[] = Array.from({ length: 7 }, (_, i) => i);
const y: number[] = Array.from({ length: 7 }, (_, i) => i);
const GRID: number[][] = y.map(yy => x.map(xx => [xx, yy])).flat();
const IDEAL_QUAD: number[][] = [[0, 1], [1, 1], [1, 0], [0, 0]];

const processBoxesAndScores = async (boxes: tf.Tensor2D, scores: tf.Tensor2D) => {
  const maxScores: tf.Tensor1D = tf.max(scores, 1);
  const argmaxScores: tf.Tensor1D = tf.argMax(scores, 1);
  const nms: tf.Tensor1D = await tf.image.nonMaxSuppressionAsync(boxes, maxScores, 100, 0.3, 0.1);
  const resTensor: tf.Tensor2D = tf.tidy(() => {
    const centers: tf.Tensor2D = getCenters(tf.gather(boxes, nms, 0));
    const cls: tf.Tensor2D = tf.expandDims(tf.gather(argmaxScores, nms, 0), 1);
    const res: tf.Tensor2D = tf.concat([centers, cls], 1);
    return res;
  });
  const res: number[][] = resTensor.arraySync();

  tf.dispose([nms, resTensor, boxes, scores, argmaxScores, maxScores])
  return res
}

const runPiecesModel = async (videoRef: any, piecesModelRef: any): Promise<number[][]> => {
  const videoWidth: number = videoRef.current.videoWidth;
  const videoHeight: number = videoRef.current.videoHeight;

  const {image4D, width, height, padding, roi} = getInput(videoRef);
  const piecesPreds: tf.Tensor3D = piecesModelRef.current.predict(image4D);
  const boxesAndScores = getBoxesAndScores(piecesPreds, width, height, videoWidth, videoHeight, padding, roi);
  const pieces: number[][] = await processBoxesAndScores(boxesAndScores.boxes, boxesAndScores.scores);
  
  tf.dispose([piecesPreds, image4D, boxesAndScores]);
  return pieces;
}

const runXcornersModel = async (videoRef: any, xcornersModelRef: any, pieces: number[][]): 
Promise<number[][]> => {
  const keypoints: number[][] = pieces.map(x => [x[0], x[1]]);
  const videoWidth: number = videoRef.current.videoWidth;
  const videoHeight: number = videoRef.current.videoHeight;

  const {image4D, width, height, padding, roi} = getInput(videoRef, keypoints);
  const xcornersPreds: tf.Tensor3D = xcornersModelRef.current.predict(image4D); 
  const boxesAndScores = getBoxesAndScores(xcornersPreds, width, height, videoWidth, videoHeight, padding, roi);
  tf.dispose([xcornersPreds, image4D]);

  let xCorners: number[][] = await processBoxesAndScores(boxesAndScores.boxes, boxesAndScores.scores);
  xCorners = xCorners.map(x => [x[0], x[1]]);
  return xCorners;
}

const getQuads = (xCorners: number[][]) => {
  const intXcorners = xCorners.flat().map(x => Math.round(x));
  const delaunay = new Delaunator(intXcorners);
  const triangles = delaunay.triangles;
  const quads = [];
  for (let i = 0; i < triangles.length; i += 3) {
    const t1 = triangles[i];
    const t2 = triangles[i + 1];
    const t3 = triangles[i + 2];
    const quad = [t1, t2, t3, -1];

    for (let j = 0; j < triangles.length; j += 3) {
      if (i === j) {
        continue;
      }
      const cond1 = (t1 === triangles[j] && t2 === triangles[j + 1]) || (t1 === triangles[j + 1] && t2 === triangles[j]);
      const cond2 = (t2 === triangles[j] && t3 === triangles[j + 1]) || (t2 === triangles[j + 1] && t3 === triangles[j]);
      const cond3 = (t3 === triangles[j] && t1 === triangles[j + 1]) || (t3 === triangles[j + 1] && t1 === triangles[j]);
      if ((cond1 || cond2 || cond3)) {
        quad[3] = triangles[j + 2];
        break;
      }
    }
    
    if (quad[3] !== -1) {
      quads.push(quad.map(x => xCorners[x]));
    }
  }
  return quads;
}

const cdist = (a: number[][], b: number[][]) => {
  const dist = Array.from({ length: a.length }, () => Array(b.length).fill(0));
  for (let i = 0; i < a.length; i++) {
    for (let j = 0; j < b.length; j++) {
      const dx = a[i][0] - b[j][0];
      const dy = a[i][1] - b[j][1];
      dist[i][j] = Math.sqrt(dx * dx + dy * dy);
    }
  }
  return dist;
}

const calculateOffsetScore = (warpedXcorners: number[][], shift: number[]) => {
  const grid = GRID.map(x => [x[0] + shift[0], x[1] + shift[1]]);
  const dist = cdist(grid, warpedXcorners);
  
  let assignmentCost = 0;
  for (let i = 0; i < dist.length; i++) {
    assignmentCost += Math.min(...dist[i]);
  }
  const score = 1 / (1 + assignmentCost);

  return score;
}

const findOffset = (warpedXcorners: number[][]) => {
  const bestOffset = [0, 0];
  for (let i = 0; i < 2; i++) {
    let low = -7;
    let high = 1;
    const scores: any = {};
    while ((high - low) > 1) {
      const mid = (high + low) >> 1;
      [mid, mid + 1].forEach(x => {
        if (!(x in scores)) {
          const shift = [0, 0];
          shift[i] = x;
          scores[x] = calculateOffsetScore(warpedXcorners, shift);
        }
      });
      if (scores[mid] > scores[mid + 1]) {
        high = mid
      } else {
        low = mid
      }
    }
    bestOffset[i] = low + 1;
  }

  return bestOffset;
}

const scoreQuad = (quad: number[][], xCorners: number[][]): [number, NDArray, number[]] => {
  const M: NDArray = getPerspectiveTransform(IDEAL_QUAD, quad);
  const warpedXcorners: number[][] = perspectiveTransform(xCorners, M);
  const offset: number[] = findOffset(warpedXcorners);

  const score: number = calculateOffsetScore(warpedXcorners, offset);
  return [score, M, offset]
}

const findCornersFromXcorners = (xCorners: number[][]) => {
  const quads: number[][][] = getQuads(xCorners);
  if (quads.length == 0) {
    return;
  }

  let bestScore: number;
  let bestM: NDArray;
  let bestOffset: number[];
  [bestScore, bestM, bestOffset] = scoreQuad(quads[0], xCorners);
  for (let i = 1; i < quads.length; i++) {
    const [score, M, offset] = scoreQuad(quads[i], xCorners);
    if (score > bestScore) {
      bestScore = score;
      bestM = M;
      bestOffset = offset;
    }
  }

  const invM = bestM.inv()
  const warpedCorners = [[bestOffset[0] - 1, bestOffset[1] - 1],
                         [bestOffset[0] - 1, bestOffset[1] + 7],
                         [bestOffset[0] + 7, bestOffset[1] + 7],
                         [bestOffset[0] + 7, bestOffset[1] - 1]]
  const corners = perspectiveTransform(warpedCorners, invM);

  // Clip bad corners
  for (let i = 0; i < 4; i++) {
    corners[i][0] = clamp(corners[i][0], 0, MODEL_WIDTH);
    corners[i][1] = clamp(corners[i][1], 0, MODEL_HEIGHT);
  }

  return corners;
}

const getCenter = (points: number[][]) => {
  let center = points.reduce((a, b) => [a[0] + b[0], a[1] + b[1]], [0, 0]);
  center = center.map(x => x / points.length);
  return center
}

const euclidean = (a: number[], b: number[]) => {
  const dx = a[0] - b[0];
  const dy = a[1] - b[1];
  const dist = Math.sqrt((dx * dx) + (dy * dy))
  return dist;
}

const calculateKeypoints = (blackPieces: number[][], whitePieces: number[][], corners: number[][]) => {
  const blackCenter = getCenter(blackPieces);
  const whiteCenter = getCenter(whitePieces);
  
  let bestShift = 0;
  let bestScore = 0;
  for (let shift = 0; shift < 4; shift++) {
    const cw = [(corners[shift % 4][0] + corners[(shift + 1) % 4][0]) / 2,
                (corners[shift % 4][1] + corners[(shift + 1) % 4][1]) / 2];
    const cb = [(corners[(shift + 2) % 4][0] + corners[(shift + 3) % 4][0]) / 2,
                (corners[(shift + 2) % 4][1] + corners[(shift + 3) % 4][1]) / 2];
    const score = 1 / (1 + euclidean(whiteCenter, cw) + euclidean(blackCenter, cb));
    if (score > bestScore) {
      bestScore = score;
      bestShift = shift;
    }
  }

  const keypoints: CornersDict = {
    "a1": corners[bestShift % 4],
    "h1": corners[(bestShift + 1) % 4],
    "h8": corners[(bestShift + 2) % 4],
    "a8": corners[(bestShift + 3) % 4]
  }
  return keypoints
}

export const _findCorners = async (piecesModelRef: any, xcornersModelRef: any, videoRef: any, 
  canvasRef: any, dispatch: any, setText: any) => {
  if (invalidVideo(videoRef)) {
    return;
  }

  const pieces = await runPiecesModel(videoRef, piecesModelRef);
  const blackPieces = pieces.filter(x => (x[2] <= 5));
  const whitePieces = pieces.filter(x => (x[2] > 5));
  if ((blackPieces.length == 0) || (whitePieces.length == 0)) {
    setText(["No pieces to label corners"]);
    return;
  }

  const xCorners = await runXcornersModel(videoRef, xcornersModelRef, pieces);
  if (xCorners.length < 5) {
    // With <= 5 xCorners, no quads are found
    setText(["Need â‰¥5 xCorners", `Detected ${xCorners.length}`]);
    return;
  }

  const corners = findCornersFromXcorners(xCorners);
  if (corners === undefined) {
    setText(["Failed to find corners"]);
    return;
  }

  const keypoints: CornersDict = calculateKeypoints(blackPieces, whitePieces, corners);

  CORNER_KEYS.forEach((key) => {
    const xy: number[] = keypoints[key];
    const payload: CornersPayload = {
      "xy": getMarkerXY(xy, canvasRef.current.height, canvasRef.current.width),
      "key": key
    }
    dispatch(cornersSet(payload)) 
  })
  renderCorners(canvasRef.current, xCorners);
  setText(["Found corners", "Ready to record"])
}

export const findCorners = async (piecesModelRef: any, xcornersModelRef: any, videoRef: any, canvasRef: any,
   dispatch: any, setText: any) => {
  const startTensors = tf.memory().numTensors;

  await _findCorners(piecesModelRef, xcornersModelRef, videoRef, canvasRef, dispatch, setText);

  const endTensors = tf.memory().numTensors;
  if (startTensors < endTensors) {
    console.error(`Memory Leak! (${endTensors} > ${startTensors})`)
  }

  return () => {
    tf.disposeVariables();
  };
}

----- D:\chessweb\src\utils\findFen.tsx -----
import * as tf from "@tensorflow/tfjs-core";
import { getInvTransform, transformBoundary, transformCenters } from "./warp";
import { invalidVideo } from "./detect";
import { detect, getKeypoints, getSquares, getUpdate} from "./findPieces";
import { Chess, Color, Piece, PieceSymbol, Square } from "chess.js";
import { PIECE_SYMBOLS, SQUARE_NAMES } from "./constants";
import { gameResetMoves, gameSetFen, gameSetStart } from "../slices/gameSlice";
import { renderState } from "./render/renderState";
import { SetStringArray } from "../types";

interface findFenInput {
  piecesModelRef: any,
  videoRef: any,
  cornersRef: any,
  canvasRef: any,
  dispatch: any,
  setText: SetStringArray,
  color: Color
}

const getFenAndError = (board: Chess, color: Color) => {
  let fen = board.fen();
  const otherColor: Color = (color === "w") ? "b" : "w";
  fen = fen.replace(` ${otherColor} `, ` ${color} `);

  let error = null;

  // Side to move has opponent in check
  for (let i = 0; i < 64; i++) {
    const square: Square = SQUARE_NAMES[i];
    const piece: Piece | undefined = board.get(square);
    if (piece === undefined) {
      continue;
    }

    const isKing: boolean = (piece.type === "k");
    const isOtherColor: boolean = (piece.color === otherColor);
    const isAttacked: boolean = board.isAttacked(square, color);

    if (isKing && isOtherColor && isAttacked) {
      error = "Side to move has opponent in check";
      return {fen, error}
    }
  }

  return {fen, error}
}

const setFenFromState = (state: number[][], color: Color, dispatch: any, setText: SetStringArray) => {
  const assignment = Array(64).fill(-1);

  // In the first pass, assign the black king
  let bestBlackKingScore = -1;
  let bestBlackKingIdx = -1;
  for (let i = 0; i < 64; i++) {
    const blackKingScore = state[i][1];
    if (blackKingScore > bestBlackKingScore) {
      bestBlackKingScore = blackKingScore;
      bestBlackKingIdx = i;
    }
  }
  assignment[bestBlackKingIdx] = 1; 

  // In the second pass, assign the white king
  let bestWhiteKingScore = -1;
  let bestWhiteKingIdx = -1;
  for (let i = 0; i < 64; i++) {
    if (i == bestBlackKingIdx) {
      continue
    }
    const whiteKingScore = state[i][7];
    if (whiteKingScore > bestWhiteKingScore) {
      bestWhiteKingScore = whiteKingScore;
      bestWhiteKingIdx = i;
    }
  }
  assignment[bestWhiteKingIdx] = 7; 

  // In the third pass, assign the remaining pieces
  const remainingPieceIdxs = [0, 2, 3, 4, 5, 6, 8, 9, 10, 11];
  for (let i = 0; i < 64; i++) {
    // Square has already been assigned
    if (assignment[i] !== -1) {
      continue
    }

    let bestIdx = null;
    let bestScore = 0.3;
    remainingPieceIdxs.forEach(j => {
      const square: Square = SQUARE_NAMES[i];
      const badRank: boolean = (square[1] === "1") || (square[1] === "8");
      const isPawn: boolean = (PIECE_SYMBOLS[j % 6] === "p");
      if (isPawn && badRank) {
        return;
      }
      
      const score = state[i][j];
      if (score > bestScore) {
        bestIdx = j;
        bestScore = score;
      }
    });

    if (bestIdx !== null) {
      assignment[i] = bestIdx;
    }
  }

  const board = new Chess();
  board.clear();
  for (let i = 0; i < 64; i++) {
    if (assignment[i] === -1) {
      continue;
    }
    const piece: PieceSymbol = PIECE_SYMBOLS[assignment[i] % 6];
    const color: Color = (assignment[i] > 5) ? 'w' : 'b';
    const square: Square = SQUARE_NAMES[i];
    board.put({'type': piece, 'color': color}, square);
  }

  const {fen, error} = getFenAndError(board, color);
  if (error === null) {
    dispatch(gameSetStart(fen));
    dispatch(gameSetFen(fen));
    dispatch(gameResetMoves());
    setText(["Set starting FEN"]);
  } else {
    setText(["Invalid FEN:", error]);
  }
}

export const _findFen = async ({piecesModelRef, videoRef, 
  cornersRef, canvasRef, dispatch, setText, color}: findFenInput) => {
  if (invalidVideo(videoRef)) {
    return;
  }
  const keypoints: number[][] = getKeypoints(cornersRef, canvasRef);
  
  const invTransform = getInvTransform(keypoints);
  const [centers, centers3D] = transformCenters(invTransform);
  const [boundary, boundary3D] = transformBoundary(invTransform);
  const {boxes, scores} = await detect(piecesModelRef, videoRef, keypoints);
  const squares: number[] = getSquares(boxes, centers3D, boundary3D);
  const state = getUpdate(scores, squares);
  setFenFromState(state, color, dispatch, setText);

  renderState(canvasRef.current, centers, boundary, state);

  tf.dispose([boxes, scores, centers3D, boundary3D]);
}

export const findFen = async ({piecesModelRef, videoRef, cornersRef, canvasRef, dispatch, setText, color}: 
  findFenInput) => {
  const startTensors = tf.memory().numTensors;

  await _findFen({piecesModelRef, videoRef, cornersRef, canvasRef, dispatch, setText, color});

  const endTensors = tf.memory().numTensors;
  if (startTensors < endTensors) {
    console.error(`Memory Leak! (${endTensors} > ${startTensors})`)
  }

  return () => {
    tf.disposeVariables();
  };
}

----- D:\chessweb\src\utils\findPieces.tsx -----
import { renderState } from "./render/renderState";
import * as tf from "@tensorflow/tfjs-core";
import { getInvTransform, transformBoundary, transformCenters } from "./warp";
import { gameUpdate, makeUpdatePayload } from "../slices/gameSlice";
import { getBoxesAndScores, getInput, getXY, invalidVideo } from "./detect";
import {  Mode, MovesData, MovesPair, DeviceType } from "../types";
import { zeros } from "./math";
import { CORNER_KEYS, SQUARE_MAP } from "./constants";
import { Chess } from "chess.js";
import { processChessboardCoordinates, setupCLI } from './transformPoses';
import { clearPieceBaseBuffer } from './robotMoveExecutor';
import { MODEL_WIDTH, MODEL_HEIGHT, LABELS, PALETTE} from "../utils/constants";

const calculateScore = (state: any, move: MovesData, from_thr=0.6, to_thr=0.6) => {
  let score = 0;
  move.from.forEach(square => {
    score += 1 - Math.max(...state[square]) - from_thr;
  })

  for (let i = 0; i < move.to.length; i++) {
    score += state[move.to[i]][move.targets[i]] - to_thr;
  }

  return score
}

const processState = (state: any, movesPairs: MovesPair[], possibleMoves: Set<string>): {
  bestScore1: number, bestScore2: number, bestJointScore: number, 
  bestMove: MovesData | null, bestMoves: MovesData | null
} => {
  let bestScore1 = Number.NEGATIVE_INFINITY;
  let bestScore2 = Number.NEGATIVE_INFINITY;
  let bestJointScore = Number.NEGATIVE_INFINITY;
  let bestMove: MovesData | null = null;
  let bestMoves: MovesData | null = null;
  const seen: Set<string> = new Set();

  movesPairs.forEach(movePair => {
    if (!(movePair.move1.sans[0] in seen)) {
      seen.add(movePair.move1.sans[0]);
      const score = calculateScore(state, movePair.move1);
      if (score > 0) {
        possibleMoves.add(movePair.move1.sans[0]);
      }
      if (score > bestScore1) {
        bestMove = movePair.move1;
        bestScore1 = score;
      }
    }

    if ((movePair.move2 === null) || (movePair.moves === null) || !(possibleMoves.has(movePair.move1.sans[0]))) {
      return;
    }
    
    const score2: number = calculateScore(state, movePair.move2);
    if (score2 < 0) {
      return;
    } else if (score2 > bestScore2) {
      bestScore2 = score2;
    }

    const jointScore: number = calculateScore(state, movePair.moves);
    if (jointScore > bestJointScore) {
      bestJointScore = jointScore;
      bestMoves = movePair.moves;
    }
  })

  return {bestScore1, bestScore2, bestJointScore, bestMove, bestMoves};
}

const getBoxCenters = (boxes: tf.Tensor2D) => {
  const boxCenters: tf.Tensor2D = tf.tidy(() => {
    const l: tf.Tensor2D = tf.slice(boxes, [0, 0], [-1, 1]);
    const r: tf.Tensor2D = tf.slice(boxes, [0, 2], [-1, 1]);
    const b: tf.Tensor2D = tf.slice(boxes, [0, 3], [-1, 1]);
    const cx: tf.Tensor2D = tf.div(tf.add(l, r), 2);
    const cy: tf.Tensor2D = tf.sub(b, tf.div(tf.sub(r, l), 3));
    const boxCenters: tf.Tensor2D = tf.concat([cx, cy], 1);
    return boxCenters;
  })
  return boxCenters;
}

export const getSquares = (boxes: tf.Tensor2D, centers3D: tf.Tensor3D, boundary3D: tf.Tensor3D): number[] => {
  const squares: number[] = tf.tidy(() => {
    const boxCenters3D: tf.Tensor3D = tf.expandDims(getBoxCenters(boxes), 1);
    const dist: tf.Tensor2D = tf.sum(tf.square(tf.sub(boxCenters3D, centers3D)), 2);
    const squares: any = tf.argMin(dist, 1);

    const shiftedBoundary3D: tf.Tensor3D = tf.concat([
      tf.slice(boundary3D, [0, 1, 0], [1, 3, 2]),
      tf.slice(boundary3D, [0, 0, 0], [1, 1, 2]),
    ], 1);

    const nBoxes: number = boxCenters3D.shape[0];
    
    const a: tf.Tensor2D = tf.squeeze(tf.sub(
      tf.slice(boundary3D, [0, 0, 0], [1, 4, 1]),
      tf.slice(shiftedBoundary3D, [0, 0, 0], [1, 4, 1])
    ), [2]);
    const b: tf.Tensor2D = tf.squeeze(tf.sub(
      tf.slice(boundary3D, [0, 0, 1], [1, 4, 1]),
      tf.slice(shiftedBoundary3D, [0, 0, 1], [1, 4, 1])
    ), [2]);
    const c: tf.Tensor2D = tf.squeeze(tf.sub(
      tf.slice(boxCenters3D, [0, 0, 0], [nBoxes, 1, 1]),
      tf.slice(shiftedBoundary3D, [0, 0, 0], [1, 4, 1])
    ), [2]);
    const d: tf.Tensor2D = tf.squeeze(tf.sub(
      tf.slice(boxCenters3D, [0, 0, 1], [nBoxes, 1, 1]),
      tf.slice(shiftedBoundary3D, [0, 0, 1], [1, 4, 1])
    ), [2]);
    
    const det: tf.Tensor2D = tf.sub(tf.mul(a, d), tf.mul(b, c));
    const newSquares: tf.Tensor1D = tf.where(
      tf.any(tf.less(det, 0), 1), 
      tf.scalar(-1), 
      squares
    );
    
    return newSquares.arraySync();
  });

  return squares;
}

export const getUpdate = (scoresTensor: tf.Tensor2D, squares: number[]) => {
  const update: number[][] = zeros(64, 12);
  const scores: number[][] = scoresTensor.arraySync();

  for (let i = 0; i < squares.length; i++) {
    const square = squares[i];
    if (square == -1) {
      continue;
    }
    for (let j = 0; j < 12; j++) {
      update[square][j] = Math.max(update[square][j], scores[i][j])
    }
  }
  return update;
}

const updateState = (state: number[][], update: number[][], decay: number=0.5) => {
  for (let i = 0; i < 64; i++) {
    for (let j = 0; j < 12; j++) {
      state[i][j] = decay * state[i][j] + (1 - decay) * update[i][j]
    }
  }
  return state
}

const sanToLan = (board: Chess, san: string): string => {
  board.move(san);
  const history: any = board.history({ verbose: true });
  const lan: string = history[history.length - 1].lan;
  board.undo();
  return lan;
}

// Function to log corner square centers to console AND process transformations
const logCornerCenters = (centers: number[][]) => {
  if (!centers || centers.length < 64) {
    console.error("Centers array is not valid");
    return;
  }

  // Get the four corner square centers (A1, H1, H8, A8)
  const a1Index = 0;   // A1
  const h1Index = 7;   // H1
  const h8Index = 63;  // H8
  const a8Index = 56;  // A8
  
  const cornerCenters = {
    a1: centers[a1Index],
    h1: centers[h1Index],
    h8: centers[h8Index],
    a8: centers[a8Index]
  };

  console.log("=== Corner Square Centers ===");
  console.log("Copy this JSON to save it:");
  console.log(JSON.stringify(cornerCenters, null, 2));
  console.log("=============================");
  
  // Process all coordinates for robot transformation
  processChessboardCoordinates(centers).then(() => {
    console.log("Square coordinate transformation completed!");
    console.log("You can now access robot coordinates in the console.");
  }).catch(error => {
    console.error("Failed to process coordinates:", error);
  });
  
  // Setup CLI interface for testing
  setupCLI();
};

export const detect = async (modelRef: any, videoRef: any, keypoints: number[][], deviceType: DeviceType = 'webcam', droidcamCanvasRef?: any): 
  Promise<{boxes: tf.Tensor2D, scores: tf.Tensor2D}> => {
  
  // For DroidCam with worker, check if canvas has content before processing
  if (deviceType === 'droidcam' && droidcamCanvasRef?.current) {
    const ctx = droidcamCanvasRef.current.getContext('2d');
    if (ctx) {
      // Check if canvas is empty or hasn't been drawn to yet
      const imageData = ctx.getImageData(0, 0, 1, 1).data;
      // Check if canvas is empty (all zeros or undefined)
      if (imageData[0] === 0 && imageData[1] === 0 && imageData[2] === 0) {
        // Return empty tensors to skip this frame
        return {
          boxes: tf.tensor2d([], [0, 4]),
          scores: tf.tensor2d([], [0, 12])
        };
      }
    }
  }

  const getInput = (videoRef: any, keypoints: number[][] | null=null, paddingRatio: number=12, deviceType: DeviceType = 'webcam', droidcamCanvasRef?: any): {
    image4D: tf.Tensor4D, width: number, height: number, padding: number[], roi: number[]
  } => {
    let roi: number[];
    let videoWidth: number, videoHeight: number;
    let sourceElement: any;
    
    if (deviceType === 'droidcam' && droidcamCanvasRef?.current) {
      // Use the DroidCam canvas as the source
      sourceElement = droidcamCanvasRef.current;
      videoWidth = sourceElement.width;
      videoHeight = sourceElement.height;
    } else {
      sourceElement = videoRef.current;
      videoWidth = sourceElement.videoWidth;
      videoHeight = sourceElement.videoHeight;
    }
    
    // Early return if source has no dimensions
    if (videoWidth === 0 || videoHeight === 0) {
      // Return dummy values to avoid errors
      const dummyTensor: tf.Tensor4D = tf.zeros([1, MODEL_HEIGHT, MODEL_WIDTH, 3]) as tf.Tensor4D;
      return {
        image4D: dummyTensor,
        width: MODEL_WIDTH,
        height: MODEL_HEIGHT,
        padding: [0, 0, 0, 0],
        roi: [0, 0, MODEL_WIDTH, MODEL_HEIGHT]
      };
    }
    
    if (keypoints !== null) {
      const bbox = getBbox(keypoints);
      let paddingLeft: number = Math.floor(bbox.width / paddingRatio);
      let paddingRight: number = Math.floor(bbox.width / paddingRatio);
      let paddingTop: number = Math.floor(bbox.height / paddingRatio);
      const paddingBottom: number = Math.floor(bbox.height / paddingRatio)

      const paddedRoiWidth: number = bbox.width + paddingLeft + paddingRight;
      const paddedRoiHeight: number = bbox.height + paddingTop + paddingBottom;
      const ratio: number = paddedRoiHeight / paddedRoiWidth;
      const desiredRatio: number = MODEL_HEIGHT / MODEL_WIDTH;

      if (ratio > desiredRatio) {
          const targetWidth: number = paddedRoiHeight / desiredRatio;
          const dx: number = targetWidth - paddedRoiWidth;
          paddingLeft += Math.floor(dx / 2);
          paddingRight += dx - Math.floor(dx / 2);
      } else {
          const targetHeight: number = paddedRoiWidth * desiredRatio;
          paddingTop += targetHeight - paddedRoiHeight;
      }
      roi = [Math.round(Math.max(videoWidth * (bbox.xmin - paddingLeft) / MODEL_WIDTH, 0)),
        Math.round(Math.max(videoHeight * (bbox.ymin - paddingTop) / MODEL_HEIGHT, 0)),
        Math.round(Math.min(videoWidth * (bbox.xmax + paddingRight) / MODEL_WIDTH, videoWidth)),
        Math.round(Math.min(videoHeight * (bbox.ymax + paddingBottom) / MODEL_HEIGHT, videoHeight))]
    } else {
      roi = [0, 0, videoWidth, videoHeight];
    }
    
    const [image4D, width, height, padding]: [tf.Tensor4D, number, number, number[]] = tf.tidy(() => {
      let image: tf.Tensor3D;
      
      if (deviceType === 'droidcam' && droidcamCanvasRef?.current) {
        // Use DroidCam video from the worker canvas
        image = tf.browser.fromPixels(droidcamCanvasRef.current);
      } else {
        // Use webcam video
        image = tf.browser.fromPixels(videoRef.current);
      }
      
      // Cropping
      image = tf.slice(image,
        [roi[1], roi[0], 0], 
        [roi[3] - roi[1], roi[2] - roi[0], 3]
      );
      const height: number = image.shape[0];
      const width: number = image.shape[1];
      
      // Resizing
      const ratio: number = height / width;
      const desiredRatio: number = MODEL_HEIGHT / MODEL_WIDTH;
      let resizeHeight: number = MODEL_HEIGHT;
      let resizeWidth: number = MODEL_WIDTH;
      if (ratio > desiredRatio) {
        resizeWidth = Math.round(MODEL_HEIGHT / ratio); 
      } else {
        resizeHeight = Math.round(MODEL_WIDTH * ratio);
      }
      image = tf.image.resizeBilinear(image, [resizeHeight, resizeWidth]);

      // Padding
      const dx: number = MODEL_WIDTH - image.shape[1];
      const dy: number = MODEL_HEIGHT - image.shape[0];
      const padRight: number = Math.floor(dx / 2);
      const padLeft: number = dx - padRight
      const padBottom: number = Math.floor(dy / 2);
      const padTop: number = dy - padBottom;
      const padding: number[] = [padLeft, padRight, padTop, padBottom]
      image = tf.pad(image, [
        [padTop, padBottom],
        [padLeft, padRight],
        [0, 0]
      ], 114);
      
      // Transpose + scale + expand
      const image4D: tf.Tensor4D = tf.expandDims(tf.div(image, 255.0), 0) as tf.Tensor4D;

      return [image4D, width, height, padding];
    });
    return {image4D, width, height, padding, roi}
  };

  const getBbox = (points: number[][]) => {
    const xs: number[] = points.map(p => p[0]);
    const ys: number[] = points.map(p => p[1]);
    const xmin: number = Math.min(...xs);
    const xmax: number = Math.max(...xs);
    const ymin: number = Math.min(...ys);
    const ymax: number = Math.max(...ys);

    const width: number = xmax - xmin;
    const height: number = ymax - ymin;

    const bbox: any = {
      "xmin": xmin,
      "xmax": xmax,
      "ymin": ymin,
      "ymax": ymax,
      "width": width,
      "height": height
    }

    return bbox
  }

  const {image4D, width, height, padding, roi} = getInput(videoRef, keypoints, 12, deviceType, droidcamCanvasRef);
  let videoWidth: number, videoHeight: number;
  let sourceElement: any;
  
  if (deviceType === 'droidcam' && droidcamCanvasRef?.current) {
    sourceElement = droidcamCanvasRef.current;
    videoWidth = sourceElement.videoWidth || sourceElement.width;
    videoHeight = sourceElement.videoHeight || sourceElement.height;
  } else {
    sourceElement = videoRef.current;
    videoWidth = sourceElement.videoWidth;
    videoHeight = sourceElement.videoHeight;
  }
  
  // Skip processing if no valid dimensions
  if (videoWidth === 0 || videoHeight === 0) {
    tf.dispose([image4D]);
    return {
      boxes: tf.tensor2d([], [0, 4]),
      scores: tf.tensor2d([], [0, 12])
    };
  }
  
  const preds: tf.Tensor3D = modelRef.current.predict(image4D);
  const {boxes, scores} = getBoxesAndScores(preds, width, height, videoWidth, videoHeight, padding, roi);
  
  tf.dispose([image4D, preds]);

  return {boxes, scores}
}

export const getKeypoints = (cornersRef: any, canvasRef: any): number[][] => {
  const keypoints = CORNER_KEYS.map(x =>
    getXY(cornersRef.current[x], canvasRef.current.height, canvasRef.current.width)
  );
  return keypoints
}

export const findPieces = (modelRef: any, videoRef: any, canvasRef: any,
playingRef: any, setText: any, dispatch: any, cornersRef: any, boardRef: any, 
movesPairsRef: any, lastMoveRef: any, moveTextRef: any, mode: Mode,
stockfishMoveRef?: any, deviceType: DeviceType = 'webcam', droidcamVideoRef?: any, droidcamUrl?: string) => {
  let centers: number[][] | null = null;
  let boundary: number[][];
  let centers3D: tf.Tensor3D;
  let boundary3D: tf.Tensor3D;
  let state: number[][];
  let keypoints: number[][];
  let possibleMoves: Set<string>;
  let requestId: number;
  let greedyMoveToTime: { [move: string] : number};
  let hasLoggedCornerCenters = false; // Flag to track if we've logged corner centers

  // Buffer for averaging piece base coordinates
  const pieceBaseBuffer: {
    source: number[][];
    captured: number[][];
    moveKey: string;
    collecting: boolean;
    framesCollected: number;
  } = {
    source: [],
    captured: [],
    moveKey: '',
    collecting: false,
    framesCollected: 0
  };

  // Ref to track last logged move to avoid repetitive logs
  const lastLoggedMoveRef = { current: '' };

  const loop = async () => {
    if (playingRef.current === false || invalidVideo(videoRef, deviceType)) {
      centers = null
    } else {
      if (centers === null) {
        keypoints = getKeypoints(cornersRef, canvasRef);
        const invTransform = getInvTransform(keypoints);
        [centers, centers3D] = transformCenters(invTransform);
        [boundary, boundary3D] = transformBoundary(invTransform);
        state = zeros(64, 12);
        possibleMoves = new Set<string>;
        greedyMoveToTime = {};
        
        // Log corner centers to console once when centers are first computed
        // AND process transformations for robot coordinates
        if (!hasLoggedCornerCenters && centers && centers.length >= 64) {
          logCornerCenters(centers);
          hasLoggedCornerCenters = true;
          
          // Add message to display
          setText((prev: string[]) => {
            const newText = [...prev];
            if (newText.length > 2) {
              // Keep FPS and move text, add our message
              newText[2] = "Corner centers logged & robot coordinates calculated";
            } else {
              newText.push("Corner centers logged & robot coordinates calculated");
            }
            return newText;
          });
        }
      }
      const startTime: number = performance.now();
      const startTensors: number = tf.memory().numTensors;

      const {boxes, scores} = await detect(modelRef, videoRef, keypoints, deviceType, droidcamVideoRef);
      const squares: number[] = getSquares(boxes, centers3D, boundary3D);
      
      // Get box centers (piece base coordinates)
      const boxCenters = getBoxCenters(boxes);
      const boxCentersArray = boxCenters.arraySync();
      tf.dispose(boxCenters);
      
      // Create a map from square to piece base coordinate
      const squareToPieceBase: {[square: number]: number[]} = {};
      for (let i = 0; i < squares.length; i++) {
        const square = squares[i];
        if (square !== -1) {
          squareToPieceBase[square] = boxCentersArray[i];
        }
      }
      
      const update: number[][] = getUpdate(scores, squares);
      state = updateState(state, update);
      const {bestScore1, bestScore2, bestJointScore, bestMove, bestMoves} = processState(state, movesPairsRef.current, possibleMoves);

      const endTime: number = performance.now();
      const fps: string = (1000 / (endTime - startTime)).toFixed(1);
      
      let hasMove: boolean = false;
      if ((bestMoves !== null) && (mode !== "play")) {
        const move: string = bestMoves.sans[0];
        hasMove = (bestScore2 > 0) && (bestJointScore > 0) && (possibleMoves.has(move));
        if (hasMove) {
          boardRef.current.move(move);
          possibleMoves.clear();
          greedyMoveToTime = {};
        }
      }

      let hasGreedyMove: boolean = false;
      if (bestMove !== null && !(hasMove) && (bestScore1 > 0)) {
        const move: string = bestMove.sans[0];
        if (!(move in greedyMoveToTime)) { 
          greedyMoveToTime[move] = endTime;
        }

        const secondElapsed = (endTime - greedyMoveToTime[move]) > 1000;
        const newMove = sanToLan(boardRef.current, move) !== lastMoveRef.current;
        hasGreedyMove = secondElapsed && newMove;
        if (hasGreedyMove) {
          boardRef.current.move(move);
          greedyMoveToTime = {greedyMove: greedyMoveToTime[move]};
        }
      }
      
      if (hasMove || hasGreedyMove) {
        // No takebacks in "play" mode
        const greedy = (mode === "play") ? false : hasGreedyMove;
        const payload = makeUpdatePayload(boardRef.current, greedy);
        console.log("payload", payload);
        dispatch(gameUpdate(payload));
      }
      
      // Calculate stockfish move coordinates if available
      let stockfishMoveCoords: { 
        sourceCoord?: number[]; 
        destCoord?: number[]; 
        sourcePieceBaseCoord?: number[];
        capturedPieceBaseCoord?: number[];
        isCapture?: boolean;
        capturedSquare?: string;
        sourceSquare?: string;
      } = {};
      
      if (stockfishMoveRef?.current?.uciMove && centers) {
        const move = stockfishMoveRef.current.uciMove;
        const isCapture = stockfishMoveRef.current.isCapture || false;
        const capturedSquare = stockfishMoveRef.current.capturedSquare || "";
        
        // Only log when move changes to avoid repetitive logs
        if (move !== lastLoggedMoveRef.current) {
          console.log("Stockfish move:", move, "Is capture:", isCapture, "Captured square:", capturedSquare);
          lastLoggedMoveRef.current = move;
        }
        
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const fromIndex = SQUARE_MAP[fromSquare];
        const toIndex = SQUARE_MAP[toSquare];
        
        if (fromIndex !== undefined && toIndex !== undefined && 
            fromIndex < centers.length && toIndex < centers.length) {
          
          // Get the actual piece base coordinate from the detected piece
          const sourcePieceBaseCoord = squareToPieceBase[fromIndex];
          
          // Get captured piece base coordinate if it's a capture
          let capturedPieceBaseCoord = undefined;
          if (isCapture && capturedSquare) {
            const capturedSquareIndex = SQUARE_MAP[capturedSquare];
            if (capturedSquareIndex !== undefined) {
              capturedPieceBaseCoord = squareToPieceBase[capturedSquareIndex];
            }
          }
          
          // Use actual piece base coordinate if available, otherwise fall back to square center
          stockfishMoveCoords = {
            sourceCoord: centers[fromIndex],
            destCoord: centers[toIndex],
            sourcePieceBaseCoord: sourcePieceBaseCoord || centers[fromIndex],
            capturedPieceBaseCoord: capturedPieceBaseCoord,
            isCapture,
            capturedSquare,
            sourceSquare: fromSquare
          };
          
          // Update the ref with actual coordinates
          stockfishMoveRef.current = {
            ...stockfishMoveRef.current,
            sourceCoord: centers[fromIndex],
            destCoord: centers[toIndex],
            sourcePieceBaseCoord: sourcePieceBaseCoord || centers[fromIndex],
            capturedPieceBaseCoord: capturedPieceBaseCoord,
            isCapture,
            capturedSquare,
            sourceSquare: fromSquare
          };
          
          // Collect piece base coordinates for averaging (first 5 frames)
          if (sourcePieceBaseCoord) {
            // Check if this is a new move
            if (pieceBaseBuffer.moveKey !== move) {
              // New move, reset buffer
              pieceBaseBuffer.source = [];
              pieceBaseBuffer.captured = [];
              pieceBaseBuffer.moveKey = move;
              pieceBaseBuffer.collecting = true;
              pieceBaseBuffer.framesCollected = 0;
              
              // Clear any previous buffer
              clearPieceBaseBuffer(move);
            }
            
            if (pieceBaseBuffer.collecting && pieceBaseBuffer.framesCollected < 5) {
              // Add current frame's coordinates to buffer
              pieceBaseBuffer.source.push(sourcePieceBaseCoord);
              
              if (isCapture && capturedPieceBaseCoord) {
                pieceBaseBuffer.captured.push(capturedPieceBaseCoord);
              }
              
              pieceBaseBuffer.framesCollected++;
              
              // After 5 frames, average and store
              if (pieceBaseBuffer.framesCollected >= 5) {
                // Average source coordinates
                const sourceSum = pieceBaseBuffer.source.reduce(
                  (acc, coord) => [acc[0] + coord[0], acc[1] + coord[1]], 
                  [0, 0]
                );
                const sourceAvg = sourceSum.map(val => val / pieceBaseBuffer.source.length);
                
                // Average captured coordinates if available
                let capturedAvg;
                if (pieceBaseBuffer.captured.length >= 5) {
                  const capturedSum = pieceBaseBuffer.captured.reduce(
                    (acc, coord) => [acc[0] + coord[0], acc[1] + coord[1]], 
                    [0, 0]
                  );
                  capturedAvg = capturedSum.map(val => val / pieceBaseBuffer.captured.length);
                }
                
                // Store averaged coordinates
                stockfishMoveRef.current = {
                  ...stockfishMoveRef.current,
                  averagedSourcePieceBase: sourceAvg,
                  averagedCapturedPieceBase: capturedAvg,
                  readyForExecution: true,
                  sourceSquareNumber: fromIndex + 1, // Convert to 1-64
                  destSquareNumber: toIndex + 1, // Convert to 1-64
                  collectedFrames: pieceBaseBuffer.framesCollected
                };
                
                pieceBaseBuffer.collecting = false;
                
                // Update UI text
                setText((prev: string[]) => {
                  const newText = [...prev];
                  // Replace or add the message at index 2
                  if (newText.length > 2) {
                    newText[2] = `Robot move ready! (${pieceBaseBuffer.framesCollected} frames averaged)`;
                  } else {
                    newText.push(`Robot move ready! (${pieceBaseBuffer.framesCollected} frames averaged)`);
                  }
                  return newText;
                });
              }
            }
          }
        }
      }
      
      // Prepare text with coordinates if stockfish move is available
      let displayText = [`FPS: ${fps}`, moveTextRef.current];
      
      // Add device type indicator
      if (deviceType === 'droidcam') {
        displayText.push(`Device: DroidCam`);
      }
      
      // Add stockfish move coordinates if available
      if (stockfishMoveCoords.sourceCoord && stockfishMoveCoords.destCoord) {
        const { sourceCoord, destCoord, sourcePieceBaseCoord, capturedPieceBaseCoord, isCapture } = stockfishMoveCoords;
        
        // Display square center coordinates (as before)
        displayText.push(`Src Square: (${sourceCoord[0].toFixed(0)}, ${sourceCoord[1].toFixed(0)})`);
        displayText.push(`Dst Square: (${destCoord[0].toFixed(0)}, ${destCoord[1].toFixed(0)})`);
        
        // Add piece base coordinates if available
        if (sourcePieceBaseCoord) {
          displayText.push(`Piece Base: (${sourcePieceBaseCoord[0].toFixed(0)}, ${sourcePieceBaseCoord[1].toFixed(0)})`);
        }
        
        // Add captured piece base coordinates if available
        if (isCapture && capturedPieceBaseCoord) {
          displayText.push(`Captured Piece: (${capturedPieceBaseCoord[0].toFixed(0)}, ${capturedPieceBaseCoord[1].toFixed(0)})`);
        }
        
        // Add collection status if collecting
        if (pieceBaseBuffer.collecting) {
          displayText.push(`Collecting: ${pieceBaseBuffer.framesCollected}/5 frames`);
        }
      }
      
      setText(displayText);
      
      renderState(canvasRef.current, centers, boundary, state, stockfishMoveCoords);

      tf.dispose([boxes, scores]);

      const endTensors: number = tf.memory().numTensors;
      if (startTensors < endTensors) {
        console.error(`Memory Leak! (${endTensors} > ${startTensors})`)
      }
    }
    requestId = requestAnimationFrame(loop);
  }
  requestId = requestAnimationFrame(loop);

  return () => {
    tf.disposeVariables();
    if (requestId) {
      window.cancelAnimationFrame(requestId);
    }
  };
};

----- D:\chessweb\src\utils\loadModels.tsx -----
import * as tf from "@tensorflow/tfjs-core";
import { loadGraphModel, GraphModel } from "@tensorflow/tfjs-converter";
import "@tensorflow/tfjs-backend-webgl"; // Add this import
import { MODEL_HEIGHT, MODEL_WIDTH } from "../utils/constants";

const LoadModels = (piecesModelRef: any, xcornersModelRef: any) => {
  if ((piecesModelRef.current !== undefined) && (xcornersModelRef.current !== undefined)) {
    return;
  }

  tf.ready().then(async () => {
    // Set the backend to WebGL explicitly
    await tf.setBackend('webgl');
    
    tf.env().set('WEBGL_EXP_CONV', true);
    tf.env().set('WEBGL_PACK', false);
    tf.env().set('ENGINE_COMPILE_ONLY', true);

    const dummyInput: tf.Tensor<tf.Rank> = tf.zeros([1, MODEL_HEIGHT, MODEL_WIDTH, 3]);

    const piecesModel: GraphModel = await loadGraphModel("480M_pieces_float16/model.json");
    const piecesOutput: tf.Tensor<tf.Rank> | tf.Tensor<tf.Rank>[] = piecesModel.execute(dummyInput);

    const xcornersModel: GraphModel = await loadGraphModel("480L_xcorners_float16/model.json");
    const xcornersOutput: tf.Tensor<tf.Rank> | tf.Tensor<tf.Rank>[]  = xcornersModel.execute(dummyInput);

    tf.dispose([dummyInput, piecesOutput, xcornersOutput]);
    
    const backend: any = tf.backend()
    backend.checkCompileCompletion();
    backend.getUniformLocations();
    tf.env().set('ENGINE_COMPILE_ONLY', false);

    piecesModelRef.current = piecesModel;
    xcornersModelRef.current = xcornersModel;
    
    console.log("TensorFlow models loaded successfully");
  })
  .catch((error) => {
    console.error("Error loading TensorFlow models:", error);
  });
};

export default LoadModels;

----- D:\chessweb\src\utils\math.tsx -----
export const clamp = (x: number, min: number, max: number) => {
  // Clamp x s.t. min <= x <= max
  return Math.max(min, Math.min(x, max));
}

export const zeros = (rows: number, columns: number) => {
  return Array.from(Array(rows), _ => Array(columns).fill(0));
}

----- D:\chessweb\src\utils\moves.tsx -----
import { Chess, Move } from "chess.js";
import { SQUARE_MAP, LABEL_MAP } from "./constants";
import { MovesData, MovesPair } from "../types";

const castlingMap: {[id: string]: number[]} = {
  "g1": [SQUARE_MAP["h1"], SQUARE_MAP["f1"], LABEL_MAP["R"]],
  "c1": [SQUARE_MAP["a1"], SQUARE_MAP["d1"], LABEL_MAP["R"]],
  "g8": [SQUARE_MAP["h8"], SQUARE_MAP["f8"], LABEL_MAP["r"]],
  "c8": [SQUARE_MAP["a8"], SQUARE_MAP["d8"], LABEL_MAP["r"]]
}

const getPieceIdx = (move: Move) => {
  let piece: string = move.piece;
  if (move?.promotion) {
    piece = move.promotion;
  }
  if (move.color == "w") {
    piece = piece.toUpperCase();
  }
  const pieceIdx: number = LABEL_MAP[piece];
  return pieceIdx;
}

const getData = (move: Move) => {
  const fromSquares: number[] = [SQUARE_MAP[move.from]];
  const toSquares = [SQUARE_MAP[move.to]];
  const targets = [getPieceIdx(move)];
  if (move.isKingsideCastle() || move.isQueensideCastle()) {
    const [from, to, target] = castlingMap[move.to];
    fromSquares.push(from);
    toSquares.push(to);
    targets.push(target);
  } else if (move.isEnPassant()) {
    const capturedPawnSquare = SQUARE_MAP[move.to[0] + move.from[1]];
    fromSquares.push(capturedPawnSquare);
  }
  const moveData: MovesData = {
    "sans": [move.san],
    "from": fromSquares,
    "to": toSquares,
    "targets": targets
  }
  return moveData;
}

const combineData = (move1Data: MovesData, move2Data: MovesData) => {
  const badSquares = move2Data.from.concat(move2Data.to);
  const from1 = move1Data.from.filter(x => !badSquares.includes(x));

  const to1 = [];
  const targets1 = [];
  for (let i = 0; i < move1Data.to.length; i++) {
    if (badSquares.includes(move1Data.to[i])) {
      continue;
    }
    to1.push(move1Data.to[i]);
    targets1.push(move1Data.targets[i]);
  }

  const from = from1.concat(move2Data.from);
  const to = to1.concat(move2Data.to);
  const targets = targets1.concat(move2Data.targets);
  
  const data: MovesData = {
    "sans": [move1Data.sans[0], move2Data.sans[0]],
    "from": from,
    "to": to,
    "targets": targets
  }
  return data;
}

export const getMovesPairs = (board: Chess) => {
  const movesPairs: MovesPair[] = [];
  board.moves({ verbose: true }).forEach(move1 => {
    const move1Data = getData(move1);
    board.move(move1);
    let done = true;
    board.moves({ verbose: true }).forEach(move2 => {
      const move2Data = getData(move2);
      const movesData = combineData(move1Data, move2Data);
      const movesPair: MovesPair = {
        "move1": move1Data,
        "move2": move2Data,
        "moves": movesData           
      }
      movesPairs.push(movesPair);
      done = false;
    });
    if (done) {
      const movesPair: MovesPair = {
        "move1": move1Data,
        "move2": null,
        "moves": null
      }
      movesPairs.push(movesPair);
    }
    board.undo();
  });
  return movesPairs;
}

----- D:\chessweb\src\utils\robotMoveExecutor.ts -----
// Store for averaging piece base coordinates
interface PieceBaseBuffer {
  sourcePieceBase: number[][];
  capturedPieceBase: number[][];
  frameCount: number;
}

const pieceBaseBuffers: Map<string, PieceBaseBuffer> = new Map();

export interface MoveExecutionData {
  sourceSquare: number; // Square number (1-64)
  destSquare: number; // Square number (1-64)
  sourcePieceBaseCamera?: number[]; // Camera coordinates of piece base
  capturedPieceBaseCamera?: number[]; // Camera coordinates of captured piece
  isCapture: boolean;
  uciMove: string;
}

export interface RobotMoveCommand {
  type: 'move' | 'gripper';
  pose?: {
    x: number;
    y: number;
    z: number;
    rx: number;
    ry: number;
    rz: number;
  };
  moveType?: 'clearance' | 'vertical';
  action?: 'open' | 'close' | 'stop' | 'move_to_width';
  width_mm?: number;
  force_n?: number;
  speed_percent?: number;
}

// Configuration - THESE ARE DEFAULTS, WILL BE OVERRIDDEN BY JSON
const CONFIG = {
  PICKUP_Z: 0.194, // 172.10 mm for picking up
  CLEARANCE_Z: 0.240, // 240 mm for clearance movement
  FRAMES_TO_AVERAGE: 5,
  GRIPPER_OPEN_WIDTH_MM: 20.0, // Open to 20mm
  GRIPPER_CLOSE_WIDTH_MM: 0.3, // Close to 0.3mm
  GRIPPER_FORCE_N: 20, // Force in Newtons
  GRIPPER_SPEED_PERCENT: 50 // Speed percentage
};

// Get home and drop poses from the loaded JSON file
const getHomePose = (): any => {
  // Check if poses are available on window (set by transformPoses.ts)
  if ((window as any).chessboardPoses) {
    return (window as any).chessboardPoses.home;
  }
  // Fallback to reasonable defaults
  return {
    x: 0.4,
    y: 0.0,
    z: 0.3,
    rx: 2.205,
    ry: -2.277,
    rz: 0.016
  };
};

const getDropPose = (): any => {
  // Check if poses are available on window (set by transformPoses.ts)
  if ((window as any).chessboardPoses) {
    return (window as any).chessboardPoses.drop;
  }
  // Fallback to reasonable defaults
  return {
    x: 0.3,
    y: -0.2,
    z: 0.28,
    rx: 2.205,
    ry: -2.277,
    rz: 0.016
  };
};

// Average coordinates over multiple frames
const averageCoordinates = (coords: number[][]): number[] => {
  if (coords.length === 0) return [0, 0];
  
  const sum = coords.reduce((acc, coord) => [acc[0] + coord[0], acc[1] + coord[1]], [0, 0]);
  return [sum[0] / coords.length, sum[1] / coords.length];
};

// Add piece base coordinate to buffer for averaging
export const addToPieceBaseBuffer = (
  moveKey: string,
  sourcePieceBase: number[],
  capturedPieceBase?: number[]
): { sourceAvg?: number[]; capturedAvg?: number[]; ready: boolean } => {
  
  if (!pieceBaseBuffers.has(moveKey)) {
    pieceBaseBuffers.set(moveKey, {
      sourcePieceBase: [],
      capturedPieceBase: [],
      frameCount: 0
    });
  }
  
  const buffer = pieceBaseBuffers.get(moveKey)!;
  
  buffer.sourcePieceBase.push(sourcePieceBase);
  if (capturedPieceBase) {
    buffer.capturedPieceBase.push(capturedPieceBase);
  }
  buffer.frameCount++;
  
  if (buffer.frameCount >= CONFIG.FRAMES_TO_AVERAGE) {
    const sourceAvg = averageCoordinates(buffer.sourcePieceBase);
    const capturedAvg = buffer.capturedPieceBase.length > 0 
      ? averageCoordinates(buffer.capturedPieceBase) 
      : undefined;
    
    // Clear buffer after use
    pieceBaseBuffers.delete(moveKey);
    
    return {
      sourceAvg,
      capturedAvg,
      ready: true
    };
  }
  
  return { ready: false };
};

// Clear buffer for a move
export const clearPieceBaseBuffer = (moveKey: string) => {
  pieceBaseBuffers.delete(moveKey);
};

// Send command via WebSocket (same as RobotControl)
const sendCommand = (command: any): Promise<void> => {
  return new Promise((resolve, reject) => {
    try {
      const ws = new WebSocket('ws://localhost:8765');
      
      ws.onopen = () => {
        console.log('Sending robot command:', command);
        ws.send(JSON.stringify(command));
        // Don't wait for response, just resolve
        setTimeout(() => {
          ws.close();
          resolve();
        }, 500);
      };
      
      ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        reject(error);
      };
      
      // Fallback in case of timeout
      setTimeout(() => {
        if (ws.readyState === WebSocket.OPEN) {
          ws.close();
        }
        resolve(); // Resolve anyway to continue execution
      }, 1000);
      
    } catch (error) {
      console.error('Failed to send command:', error);
      reject(error);
    }
  });
};

// Execute a single robot command with delay
const executeCommand = async (command: RobotMoveCommand, delay: number = 3500): Promise<void> => {
  try {
    await sendCommand(command);
    // Wait for the robot to complete the move
    await new Promise(resolve => setTimeout(resolve, delay));
  } catch (error) {
    console.error('Command execution failed:', error);
    throw error;
  }
};

// Generate and execute robot move commands
export const executeRobotMove = async (moveData: MoveExecutionData): Promise<void> => {
  const { sourceSquare, destSquare, isCapture } = moveData;
  
  console.log('Executing robot move:', moveData);
  
  // Get square center poses from transformPoses
  const getSquarePose = (window as any).getSquarePose;
  const getFullRobotPose = (window as any).getFullRobotPose;
  
  if (!getSquarePose || !getFullRobotPose) {
    throw new Error('Square pose functions not available. Calibrate first!');
  }
  
  const sourceSquarePoseRobot = getSquarePose(sourceSquare);
  const destSquarePoseRobot = getSquarePose(destSquare);
  
  if (!sourceSquarePoseRobot || !destSquarePoseRobot) {
    throw new Error('Square poses not available. Calibrate first!');
  }
  
  // Get orientation from JSON (use first corner's orientation)
  let orientation = { rx: 2.205, ry: -2.277, rz: 0.016 };
  if ((window as any).chessboardPoses && (window as any).chessboardPoses.corners && (window as any).chessboardPoses.corners[0]) {
    const corner = (window as any).chessboardPoses.corners[0];
    orientation = { rx: corner.rx, ry: corner.ry, rz: corner.rz };
  }
  
  // Get home and drop poses from JSON
  const homePose = getHomePose();
  const dropPose = getDropPose();
  
  console.log('Using poses from JSON:', {
    home: homePose,
    drop: dropPose,
    orientation,
    gripperConfig: {
      openWidth: CONFIG.GRIPPER_OPEN_WIDTH_MM,
      closeWidth: CONFIG.GRIPPER_CLOSE_WIDTH_MM,
      force: CONFIG.GRIPPER_FORCE_N,
      speed: CONFIG.GRIPPER_SPEED_PERCENT
    }
  });
  
  // Create poses with proper Z heights
  const sourceSquareClearance = [...sourceSquarePoseRobot];
  const destSquareClearance = [...destSquarePoseRobot];
  const sourceSquarePickup = [...sourceSquarePoseRobot];
  const destSquarePickup = [...destSquarePoseRobot];
  
  // Set Z heights
  sourceSquareClearance[2] = CONFIG.CLEARANCE_Z;
  destSquareClearance[2] = CONFIG.CLEARANCE_Z;
  sourceSquarePickup[2] = CONFIG.PICKUP_Z;
  destSquarePickup[2] = CONFIG.PICKUP_Z;
  
  // Convert to pose objects
  const createPose = (coords: number[]) => ({
    x: coords[0],
    y: coords[1],
    z: coords[2],
    rx: orientation.rx,
    ry: orientation.ry,
    rz: orientation.rz
  });
  
  if (!isCapture) {
    // Non-capturing move sequence
    await executeCommand({
      type: 'move',
      pose: createPose(sourceSquareClearance),
      moveType: 'clearance'
    }, 3500);
    
    await executeCommand({
      type: 'move',
      pose: createPose(sourceSquarePickup),
      moveType: 'vertical'
    }, 1000);
    
    await executeCommand({
      type: 'gripper',
      action: 'close',
      width_mm: CONFIG.GRIPPER_CLOSE_WIDTH_MM,
      force_n: CONFIG.GRIPPER_FORCE_N,
      speed_percent: CONFIG.GRIPPER_SPEED_PERCENT
    }, 500);
    
    await executeCommand({
      type: 'move',
      pose: createPose(sourceSquareClearance),
      moveType: 'vertical'
    }, 1000);
    
    await executeCommand({
      type: 'move',
      pose: createPose(destSquareClearance),
      moveType: 'clearance'
    }, 3500);
    
    await executeCommand({
      type: 'move',
      pose: createPose(destSquarePickup),
      moveType: 'vertical'
    }, 1000);
    
    await executeCommand({
      type: 'gripper',
      action: 'open',
      width_mm: CONFIG.GRIPPER_OPEN_WIDTH_MM,
      force_n: CONFIG.GRIPPER_FORCE_N,
      speed_percent: CONFIG.GRIPPER_SPEED_PERCENT
    }, 500);
    
    await executeCommand({
      type: 'move',
      pose: createPose(destSquareClearance),
      moveType: 'vertical'
    }, 1000);
    
    await executeCommand({
      type: 'move',
      pose: homePose,
      moveType: 'clearance'
    }, 4000);
    
  } else {
    // Capturing move sequence
    
    // Step 1: Remove captured piece
    await executeCommand({
      type: 'move',
      pose: createPose(destSquareClearance),
      moveType: 'clearance'
    }, 3500);
    
    await executeCommand({
      type: 'move',
      pose: createPose(destSquarePickup),
      moveType: 'vertical'
    }, 1000);
    
    await executeCommand({
      type: 'gripper',
      action: 'close',
      width_mm: CONFIG.GRIPPER_CLOSE_WIDTH_MM,
      force_n: CONFIG.GRIPPER_FORCE_N,
      speed_percent: CONFIG.GRIPPER_SPEED_PERCENT
    }, 500);
    
    await executeCommand({
      type: 'move',
      pose: createPose(destSquareClearance),
      moveType: 'vertical'
    }, 1000);
    
    await executeCommand({
      type: 'move',
      pose: { ...dropPose, z: CONFIG.CLEARANCE_Z },
      moveType: 'clearance'
    }, 3500);
    
    await executeCommand({
      type: 'move',
      pose: dropPose,
      moveType: 'vertical'
    }, 1000);
    
    await executeCommand({
      type: 'gripper',
      action: 'open',
      width_mm: CONFIG.GRIPPER_OPEN_WIDTH_MM,
      force_n: CONFIG.GRIPPER_FORCE_N,
      speed_percent: CONFIG.GRIPPER_SPEED_PERCENT
    }, 500);
    
    await executeCommand({
      type: 'move',
      pose: { ...dropPose, z: CONFIG.CLEARANCE_Z },
      moveType: 'vertical'
    }, 1000);
    
    // Step 2: Move capturing piece
    await executeCommand({
      type: 'move',
      pose: createPose(sourceSquareClearance),
      moveType: 'clearance'
    }, 3500);
    
    await executeCommand({
      type: 'move',
      pose: createPose(sourceSquarePickup),
      moveType: 'vertical'
    }, 1000);
    
    await executeCommand({
      type: 'gripper',
      action: 'close',
      width_mm: CONFIG.GRIPPER_CLOSE_WIDTH_MM,
      force_n: CONFIG.GRIPPER_FORCE_N,
      speed_percent: CONFIG.GRIPPER_SPEED_PERCENT
    }, 500);
    
    await executeCommand({
      type: 'move',
      pose: createPose(sourceSquareClearance),
      moveType: 'vertical'
    }, 1000);
    
    await executeCommand({
      type: 'move',
      pose: createPose(destSquareClearance),
      moveType: 'clearance'
    }, 3500);
    
    await executeCommand({
      type: 'move',
      pose: createPose(destSquarePickup),
      moveType: 'vertical'
    }, 1000);
    
    await executeCommand({
      type: 'gripper',
      action: 'open',
      width_mm: CONFIG.GRIPPER_OPEN_WIDTH_MM,
      force_n: CONFIG.GRIPPER_FORCE_N,
      speed_percent: CONFIG.GRIPPER_SPEED_PERCENT
    }, 500);
    
    await executeCommand({
      type: 'move',
      pose: createPose(destSquareClearance),
      moveType: 'vertical'
    }, 1000);
    
    await executeCommand({
      type: 'move',
      pose: homePose,
      moveType: 'clearance'
    }, 4000);
  }
  
  console.log('âœ… Robot move sequence completed with specified gripper widths');
};

----- D:\chessweb\src\utils\stockfish.tsx -----
// src/utils/stockfish.tsx
export class StockfishEngine {
  private worker: Worker | null = null;
  private isReady: boolean = false;
  private messageHandlers: Array<(data: string) => void> = [];
  private resolveReady: ((value: boolean) => void) | null = null;
  
  constructor() {
    this.initEngine();
  }
  
  private initEngine() {
    try {
      console.log('Initializing Stockfish engine...');
      
      // Create worker
      this.worker = new Worker('/stockfish-worker.js');
      
      this.worker.onmessage = (event: MessageEvent) => {
        const data = event.data;
        console.log("Stockfish:", data);
        
        this.messageHandlers.forEach(handler => handler(data));
        
        if (data === 'readyok' || data === 'uciok') {
          this.isReady = true;
          console.log('Stockfish engine ready');
          if (this.resolveReady) {
            this.resolveReady(true);
          }
        }
        
        if (data.startsWith('error:')) {
          console.error('Stockfish error:', data);
          this.isReady = false;
        }
      };
      
      this.worker.onerror = (error) => {
        console.error('Stockfish worker error:', error);
        this.isReady = false;
      };
      
      // Initialize
      this.worker.postMessage('init');
      
      // Set a timeout to mark as ready if no response
      setTimeout(() => {
        if (!this.isReady) {
          console.log('Stockfish timeout, using fallback mode');
          this.isReady = true;
        }
      }, 3000);
      
    } catch (error) {
      console.error('Failed to initialize Stockfish:', error);
      this.isReady = true; // Fallback to simulation mode
    }
  }
  
  waitForReady(): Promise<boolean> {
    if (this.isReady) {
      return Promise.resolve(true);
    }
    
    return new Promise((resolve) => {
      this.resolveReady = resolve;
      
      // Timeout after 5 seconds
      setTimeout(() => {
        if (this.resolveReady) {
          this.resolveReady(false);
          this.resolveReady = null;
        }
      }, 5000);
    });
  }
  
  async sendCommand(cmd: string) {
    if (!this.isReady) {
      await this.waitForReady();
    }
    
    if (this.worker) {
      console.log("Stockfish command:", cmd);
      this.worker.postMessage(cmd);
    } else {
      console.log("Stockfish (simulated):", cmd);
    }
  }
  
  onMessage(handler: (data: string) => void) {
    this.messageHandlers.push(handler);
  }
  
  offMessage(handler: (data: string) => void) {
    const index = this.messageHandlers.indexOf(handler);
    if (index > -1) {
      this.messageHandlers.splice(index, 1);
    }
  }
  
  async getBestMove(fen: string, timeMs: number = 1000): Promise<string | null> {
    if (!this.isReady) {
      await this.waitForReady();
    }
    
    return new Promise((resolve) => {
      const moveHandler = (data: string) => {
        if (data.startsWith('bestmove')) {
          const match = data.match(/bestmove (\S+)/);
          if (match && match[1] && match[1] !== '(none)') {
            this.offMessage(moveHandler);
            console.log(`Stockfish best move from ${fen}: ${match[1]}`);
            resolve(match[1]);
          }
        }
      };
      
      this.onMessage(moveHandler);
      
      // Send commands
      this.sendCommand(`position fen ${fen}`);
      this.sendCommand(`go movetime ${timeMs}`);
      
      // Timeout fallback with random move
      setTimeout(() => {
        this.sendCommand('stop');
        this.offMessage(moveHandler);
        
        // Return a random move as fallback
        const moves = ['e2e4', 'd2d4', 'g1f3', 'b1c3', 'e2e3', 'g2g3'];
        const randomMove = moves[Math.floor(Math.random() * moves.length)];
        console.log('Stockfish timeout, returning random move:', randomMove);
        resolve(randomMove);
      }, timeMs + 3000);
    });
  }
  
  async getEvaluation(fen: string, depth: number = 12): Promise<number | null> {
    if (!this.isReady) {
      await this.waitForReady();
    }
    
    return new Promise((resolve) => {
      const evalHandler = (data: string) => {
        if (data.includes('score cp')) {
          const match = data.match(/score cp (-?\d+)/);
          if (match) {
            const cp = parseInt(match[1], 10);
            this.offMessage(evalHandler);
            resolve(cp / 100); // Convert centipawns to pawns
          }
        } else if (data.includes('score mate')) {
          const match = data.match(/score mate (-?\d+)/);
          if (match) {
            const mateIn = parseInt(match[1], 10);
            this.offMessage(evalHandler);
            // Convert mate to a large eval
            resolve(mateIn > 0 ? 100 : -100);
          }
        }
      };
      
      this.onMessage(evalHandler);
      
      // Send commands
      this.sendCommand(`position fen ${fen}`);
      this.sendCommand(`go depth ${depth}`);
      
      // Timeout fallback
      setTimeout(() => {
        this.sendCommand('stop');
        this.offMessage(evalHandler);
        const randomEval = (Math.random() - 0.5) * 3;
        console.log('Stockfish eval timeout, returning random eval:', randomEval);
        resolve(randomEval);
      }, 3000);
    });
  }
  
  quit() {
    if (this.worker) {
      this.worker.terminate();
      this.worker = null;
    }
  }
}

// Singleton instance
let engineInstance: StockfishEngine | null = null;

export const getStockfishEngine = (): StockfishEngine => {
  if (!engineInstance) {
    engineInstance = new StockfishEngine();
  }
  return engineInstance;
};

// Export functions for compatibility
export const getStockfishMove = async (fen: string, timeMs: number = 1000): Promise<string | null> => {
  const engine = getStockfishEngine();
  return await engine.getBestMove(fen, timeMs);
};

export const getStockfishEvaluation = async (fen: string): Promise<number | null> => {
  const engine = getStockfishEngine();
  return await engine.getEvaluation(fen, 12);
};

----- D:\chessweb\src\utils\stockfishGame.tsx -----
import { Chess } from "chess.js";
import { getStockfishMove } from "./stockfish";

export interface StockfishMoveResult {
  move: string | null;
  // Remove evaluation and mateIn since we don't have them in the current implementation
}

export class StockfishGame {
  private board: Chess;
  private isCalculating: boolean = false;
  
  constructor(fen?: string) {
    this.board = fen ? new Chess(fen) : new Chess();
  }
  
  getFen(): string {
    return this.board.fen();
  }
  
  getTurn(): 'w' | 'b' {
    return this.board.turn();
  }
  
  // Check if it's Stockfish's turn (Stockfish always plays opposite of player)
  isStockfishTurn(playerColor: 'w' | 'b'): boolean {
    return this.board.turn() !== playerColor;
  }
  
  // Make a move (from player or from previous Stockfish calculation)
  makeMove(moveUci: string): boolean {
    try {
      const move = this.board.move(moveUci);
      return !!move;
    } catch (error) {
      console.error('Invalid move:', error);
      return false;
    }
  }
  
  // Get Stockfish's move - returns only move, no evaluation in current implementation
  async getEngineMove(timeMs: number = 1000): Promise<StockfishMoveResult> {
    if (this.isCalculating) {
      console.warn('Stockfish already calculating');
      return { move: null };
    }
    
    this.isCalculating = true;
    
    const move = await getStockfishMove(this.board.fen(), timeMs);
    
    this.isCalculating = false;
    
    return { move };
  }
  
  reset() {
    this.board.reset();
  }
  
  loadFen(fen: string): boolean {
    try {
      this.board = new Chess(fen);
      return true;
    } catch (error) {
      console.error('Invalid FEN:', error);
      return false;
    }
  }
}

// Singleton instance
let gameInstance: StockfishGame | null = null;

export const getStockfishGame = (): StockfishGame => {
  if (!gameInstance) {
    gameInstance = new StockfishGame();
  }
  return gameInstance;
};

----- D:\chessweb\src\utils\stockfishSimple.tsx -----
// Simple Stockfish wrapper that mimics the OG Lichess API pattern

export class SimpleStockfish {
  private isReady: boolean = false;
  private worker: Worker | null = null;
  
  constructor() {
    this.init();
  }
  
  private init() {
    // Simulate Stockfish initialization
    setTimeout(() => {
      this.isReady = true;
      console.log("Stockfish ready (simulated)");
    }, 1000);
  }
  
  async getMove(fen: string, timeMs: number = 1000): Promise<string | null> {
    if (!this.isReady) {
      console.warn("Stockfish not ready");
      return null;
    }
    
    // Simulate thinking time and return a simple move
    return new Promise((resolve) => {
      setTimeout(() => {
        const moves = ['e2e4', 'd2d4', 'g1f3', 'b1c3', 'e2e3'];
        const randomMove = moves[Math.floor(Math.random() * moves.length)];
        console.log("Stockfish playing:", randomMove);
        resolve(randomMove);
      }, 1000);
    });
  }
  
  reset() {
    this.isReady = true;
  }
}

let instance: SimpleStockfish | null = null;

export const getStockfish = (): SimpleStockfish => {
  if (!instance) {
    instance = new SimpleStockfish();
  }
  return instance;
};

export const getStockfishEvaluation = async (fen: string): Promise<number | null> => {
  return new Promise((resolve) => {
    setTimeout(() => {
      const randomEval = (Math.random() - 0.5) * 3;
      resolve(randomEval);
    }, 500);
  });
};

----- D:\chessweb\src\utils\testSquareCoordinates.ts -----
import { getSquarePose, getSquareInfo } from './transformPoses';

// Simple function to test square coordinates
export const testSquareCoordinates = (squareNumber: number): void => {
  const pose = getSquarePose(squareNumber);
  const info = getSquareInfo(squareNumber);
  
  if (pose && info) {
    console.log(`=== Square ${squareNumber} (${info.squareName}) ===`);
    console.log(`Robot Coordinates:`);
    console.log(`  X: ${pose[0].toFixed(4)}`);
    console.log(`  Y: ${pose[1].toFixed(4)}`);
    console.log(`===============================`);
  } else {
    console.log(`Coordinates for square ${squareNumber} not available yet.`);
    console.log(`Make sure to calibrate corners and press Play first.`);
  }
};

// Expose to window for easy testing
if (typeof window !== 'undefined') {
  (window as any).testSquare = testSquareCoordinates;
  console.log('Test command available: testSquare(11)');
}

----- D:\chessweb\src\utils\transformPoses.ts -----
import { getPerspectiveTransform, perspectiveTransform } from "./warp";
import { SQUARE_NAMES } from "./constants";

// Types for robot poses
export interface RobotPose {
  x: number;
  y: number;
  z: number;
  rx: number;
  ry: number;
  rz: number;
}

interface ChessboardPoses {
  corners: RobotPose[];
  home: RobotPose;
  drop: RobotPose;
}

// Global storage for transformed coordinates
let transformedCenters: number[][] = [];
let transformationMatrix: any = null;
let chessboardPoses: ChessboardPoses | null = null; // Store loaded poses globally

// Function to load and parse the chessboard_poses.json file
export const loadChessboardPoses = async (): Promise<ChessboardPoses> => {
  try {
    const response = await fetch('/chessboard_poses.json');
    const data: ChessboardPoses = await response.json();
    chessboardPoses = data; // Store globally for later use
    console.log('Loaded chessboard poses:', data);
    return data;
  } catch (error) {
    console.error('Failed to load chessboard poses:', error);
    throw error;
  }
};

// Calculate transformation matrix from camera coordinates to robot coordinates
export const calculateTransformation = (
  cameraCornerCenters: number[][], // [A1, H1, H8, A8] camera coordinates
  robotCornerPoses: number[][]     // [A1, H1, H8, A8] robot coordinates (x, y)
): any => {
  // Camera points: A1, H1, H8, A8
  const cameraPoints = [
    cameraCornerCenters[0],  // A1
    cameraCornerCenters[7],  // H1
    cameraCornerCenters[63], // H8
    cameraCornerCenters[56], // A8
  ];

  // Robot points from JSON: A1, H1, H8, A8 (only x, y)
  const robotPoints = robotCornerPoses;

  console.log('Calculating transformation matrix...');
  console.log('Camera corner centers:', cameraPoints);
  console.log('Robot corner poses:', robotPoints);

  // Calculate transformation matrix (from camera to robot coordinates)
  const transform = getPerspectiveTransform(robotPoints, cameraPoints);
  transformationMatrix = transform;
  
  console.log('Transformation matrix calculated:', transform);
  return transform;
};

// Apply transformation to all square centers
export const transformAllSquares = (
  allCameraCenters: number[][], // All 64 square centers from camera
  transformation: any
): number[][] => {
  if (!transformation) {
    console.error('No transformation matrix available');
    return [];
  }

  // Transform all 64 centers
  const transformed = perspectiveTransform(allCameraCenters, transformation);
  transformedCenters = transformed;
  
  console.log('Transformed all squares:', transformed);
  return transformed;
};

// Get transformed coordinates for a specific square (1-64)
export const getSquarePose = (squareNumber: number): number[] | null => {
  if (squareNumber < 1 || squareNumber > 64) {
    console.error('Square number must be between 1 and 64');
    return null;
  }
  
  if (transformedCenters.length < 64) {
    console.error('Transformed centers not available yet. Calibrate first!');
    return null;
  }
  
  return transformedCenters[squareNumber - 1]; // Convert to 0-based index
};

// Get full robot pose including Z and orientation
export const getFullRobotPose = (squareNumber: number): RobotPose | undefined => {
  const xyPose = getSquarePose(squareNumber);
  if (!xyPose || !chessboardPoses) {
    console.error('Cannot get full robot pose. Calibrate first or poses not loaded.');
    return undefined;
  }
  
  // Use first corner's Z and orientation as default
  const cornerPose = chessboardPoses.corners[0];
  
  return {
    x: xyPose[0],
    y: xyPose[1],
    z: cornerPose.z,     // From JSON
    rx: cornerPose.rx,   // From JSON
    ry: cornerPose.ry,   // From JSON
    rz: cornerPose.rz    // From JSON
  };
};

// Get square name and pose for a given number
export const getSquareInfo = (squareNumber: number): {
  squareName: string;
  cameraX: number;
  cameraY: number;
  robotX?: number;
  robotY?: number;
  fullPose?: RobotPose;
} | null => {
  if (squareNumber < 1 || squareNumber > 64) {
    return null;
  }
  
  const index = squareNumber - 1;
  const squareName = SQUARE_NAMES[index];
  
  // Try to get camera coordinates from global cache
  let cameraX = 0;
  let cameraY = 0;
  if (typeof window !== 'undefined' && (window as any).centersCache) {
    const cameraCenters = (window as any).centersCache;
    if (cameraCenters.length > index) {
      cameraX = cameraCenters[index][0];
      cameraY = cameraCenters[index][1];
    }
  }
  
  // Get robot coordinates
  const robotPose = getSquarePose(squareNumber);
  const fullPose = getFullRobotPose(squareNumber);
  
  return {
    squareName,
    cameraX,
    cameraY,
    robotX: robotPose?.[0],
    robotY: robotPose?.[1],
    fullPose
  };
};

// Store poses on window for access by robotMoveExecutor
export const storePosesOnWindow = (poses: any) => {
  if (typeof window !== 'undefined') {
    (window as any).chessboardPoses = poses;
    console.log('Chessboard poses stored on window:', poses);
  }
};

// Main function to process everything
export const processChessboardCoordinates = async (
  cameraCenters: number[][] // All 64 square centers from camera
): Promise<void> => {
  if (!cameraCenters || cameraCenters.length < 64) {
    console.error('Invalid camera centers array');
    return;
  }
  
  // Store camera centers globally for access
  if (typeof window !== 'undefined') {
    (window as any).centersCache = cameraCenters;
  }
  
  try {
    // Load robot poses
    const poses = await loadChessboardPoses();
    
    // Store poses on window for robotMoveExecutor to access
    storePosesOnWindow(poses);
    
    // Extract robot corner coordinates (x, y only)
    const robotCorners = poses.corners.map(pose => [pose.x, pose.y]);
    
    // Calculate transformation
    const transform = calculateTransformation(cameraCenters, robotCorners);
    
    // Transform all squares
    const transformed = transformAllSquares(cameraCenters, transform);
    
    console.log('=== TRANSFORMATION COMPLETE ===');
    console.log('All 64 squares have been transformed to robot coordinates');
    console.log('Default Z height:', poses.corners[0].z);
    console.log('Default orientation:', poses.corners[0].rx, poses.corners[0].ry, poses.corners[0].rz);
    console.log('Home pose:', poses.home);
    console.log('Drop pose:', poses.drop);
    console.log('Use getSquareInfo(squareNumber) to get coordinates');
    console.log('Example: getSquareInfo(11) for C2');
    console.log('================================');
    
  } catch (error) {
    console.error('Failed to process chessboard coordinates:', error);
  }
};

// Get all transformed centers for debugging/export
export const getAllTransformedCenters = (): number[][] => {
  return transformedCenters;
};

// Export a simple CLI-like interface for testing
export const setupCLI = () => {
  if (typeof window !== 'undefined') {
    (window as any).getSquarePose = getSquarePose;
    (window as any).getSquareInfo = getSquareInfo;
    (window as any).getFullRobotPose = getFullRobotPose;
    (window as any).transformedCenters = transformedCenters;
    (window as any).getAllTransformedCenters = getAllTransformedCenters;
    (window as any).chessboardPoses = chessboardPoses;
    
    console.log('=== CHESSBOARD COORDINATES CLI ===');
    console.log('Commands available in console:');
    console.log('- getSquarePose(11) - Get robot XY coordinates for square 11');
    console.log('- getSquareInfo(11) - Get square name and all coordinates');
    console.log('- getFullRobotPose(11) - Get full robot pose (with Z and orientation)');
    console.log('- transformedCenters - Array of all 64 transformed centers');
    console.log('- getAllTransformedCenters() - Function to get all centers');
    console.log('- chessboardPoses - The loaded chessboard poses from JSON');
    console.log('==================================');
  }
};

// Transform camera coordinates to robot coordinates using existing transformation
export const transformCameraToRobot = (cameraPoint: number[]): number[] => {
  if (!transformationMatrix) {
    console.error('Transformation matrix not available. Calibrate first!');
    return cameraPoint; // Fallback to camera coordinates
  }
  
  try {
    // Add homogeneous coordinate
    const pointWithHomogeneous = [cameraPoint[0], cameraPoint[1], 1];
    const transformed = perspectiveTransform([pointWithHomogeneous], transformationMatrix);
    return transformed[0];
  } catch (error) {
    console.error('Failed to transform camera point:', error);
    return cameraPoint;
  }
};

// Export existing variables/functions that might be needed
export { transformationMatrix, transformedCenters };

----- D:\chessweb\src\utils\warp.tsx -----
import { array, NDArray, zeros } from 'vectorious';
import { BOARD_SIZE, SQUARE_SIZE } from "./constants";
import * as tf from "@tensorflow/tfjs-core";

export const perspectiveTransform = (src: number[][], transform: any): number[][] => {
    if (src[0].length == 2) {
      src = src.map(x => [x[0], x[1], 1]);
    }
    const warpedSrc: any = array(src).multiply(transform.T);

    for (let i = 0; i < warpedSrc.shape[0]; i++) {
      const x = warpedSrc.get(i, 0);
      const y = warpedSrc.get(i, 1);
      const w = warpedSrc.get(i, 2);
      warpedSrc.set(i, 0, x / w);
      warpedSrc.set(i, 1, y / w);
    }

    let warpedSrcArray: number[][] = warpedSrc.toArray();
    warpedSrcArray = warpedSrcArray.map(row => row.slice(0, 2));

    return warpedSrcArray
}

export const getPerspectiveTransform = (target: number[][], keypoints: number[][]): NDArray => {
    const A: NDArray = zeros(8, 8);
    const B: NDArray = zeros(8, 1);

    for (let i = 0; i < 4; i++) {
        const [x, y] = keypoints[i];
        const [u, v] = target[i];
        A.set(i * 2, 0, x);
        A.set(i * 2, 1, y);
        A.set(i * 2, 2, 1);
        A.set(i * 2, 6, -u * x);
        A.set(i * 2, 7, -u * y);
        A.set(i * 2 + 1, 3, x);
        A.set(i * 2 + 1, 4, y);
        A.set(i * 2 + 1, 5, 1);
        A.set(i * 2 + 1, 6, -v * x);
        A.set(i * 2 + 1, 7, -v * y);
        B.set(i * 2, 0, u);
        B.set(i * 2 + 1, 0, v);
    }

    const solution = A.solve(B).toArray();
    const transform: NDArray = array([...solution, 1], {
      shape: [3, 3],
    });

    return transform
}

export const getInvTransform = (keypoints: number[][]): NDArray => {
  const target: number[][] = [
    [BOARD_SIZE, BOARD_SIZE],
    [0, BOARD_SIZE],
    [0, 0],
    [BOARD_SIZE, 0]
  ];

  const transform: NDArray = getPerspectiveTransform(target, keypoints);
  const invTransform: NDArray = transform.inv();
  return invTransform
}

export const transformCenters = (invTransform: any): [number[][], tf.Tensor3D] => {
  const x: number[] = Array.from({ length: 8 }, (_, i) => 0.5 + i);
  const y: number[] = Array.from({ length: 8 }, (_, i) => 7.5 - i);
  const warpedCenters: number[][] = y.map(yy => 
    x.map(xx => 
      [xx * SQUARE_SIZE, yy * SQUARE_SIZE, 1]
    )
  ).flat();
  const centers: number[][] = perspectiveTransform(warpedCenters, invTransform);
  const centers3D: tf.Tensor3D = tf.tidy(() => {
    return tf.expandDims(tf.tensor2d(centers), 0);
  });
  return [centers, centers3D]
}

export const transformBoundary = (invTransform: any): [number[][], tf.Tensor3D] => {
  const warpedBoundary: number[][] = [
    [-0.5 * SQUARE_SIZE, -0.5 * SQUARE_SIZE, 1],
    [-0.5 * SQUARE_SIZE, 8.5 * SQUARE_SIZE, 1],
    [8.5 * SQUARE_SIZE, 8.5 * SQUARE_SIZE, 1],
    [8.5 * SQUARE_SIZE, -0.5 * SQUARE_SIZE, 1]
  ]
  const boundary: number[][] = perspectiveTransform(warpedBoundary, invTransform);
  const boundary3D: tf.Tensor3D = tf.tidy(() => {
    return tf.expandDims(tf.tensor2d(boundary), 0);
  });
  return [boundary, boundary3D];
}

----- D:\chessweb\src\utils\render\common.tsx -----
import { MODEL_WIDTH, MODEL_HEIGHT } from "../constants";

export const clearCtx = (ctx: any) => {
  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
}

export const setupCtx = (canvasRef: any) => {
  const ctx = canvasRef.getContext("2d");
  ctx.globalAlpha = 0.8;
  const width = ctx.canvas.width;
  const height = ctx.canvas.height;

  clearCtx(ctx);

  const fontSize = Math.max(Math.round(Math.max(width, height) / 40), 14);
  const font = `${fontSize}px Arial`;
  const fontHeight = parseInt(font, 10);
  const lineWidth = Math.max(Math.min(width, height) / 200, 2.5);
  
  ctx.textBaseline = "top";
  ctx.lineWidth = lineWidth;
  ctx.font = font;

  const sx = width / MODEL_WIDTH;
  const sy = height / MODEL_HEIGHT;

  return [ctx, fontHeight, lineWidth, sx, sy];
}

export const drawPoints = (ctx: any, points: number[][], colour: string, sx: number, sy: number) => {
  ctx.strokeStyle = colour;
  points.forEach((p, _) => {
    ctx.strokeRect(p[0] * sx, p[1] * sy, 1, 1);
  })
}

export const drawDict = (ctx: any, dict: { [id: string]: number[] }, colour: string, sx: number, sy: number, fontHeight: number, lineWidth: number) => {
  ctx.strokeStyle = colour;
  for (const [text, p] of Object.entries(dict)) {
    const x = p[0] * sx;
    const y = p[1] * sy;
    const textWidth = ctx.measureText(text).width;

    ctx.strokeRect(x, y, 1, 1);

    ctx.fillStyle = colour;
    const w = textWidth + lineWidth;
    const h = fontHeight + lineWidth;

    ctx.fillStyle = "#ffffff";
    ctx.fillText(text, x - (w / 2), y - (h / 2));
  }
}

export const drawPolygon = (ctx: any, polygon: number[][], colour: string, sx: number, sy: number) => {
  ctx.strokeStyle = colour;
  ctx.beginPath();
  const n = polygon.length;
  for (let i = 0; i < n; i++) {
    ctx.moveTo(polygon[i][0] * sx, polygon[i][1] * sy);
    ctx.lineTo(polygon[(i+1) % n][0] * sx, polygon[(i+1) % n][1] * sy);
  }
  ctx.stroke();
}

export const drawBox = (ctx: any, colour: string, cx: number, cy: number, text: string, fontHeight: number, lineWidth: number) => {
  ctx.fillStyle = colour;
  const textWidth = ctx.measureText(text).width;
  const y = cy - lineWidth - fontHeight / 2;
  const x = cx - textWidth / 2;
  ctx.fillRect(
    x,
    y,
    textWidth + lineWidth,
    fontHeight + lineWidth
  );

  // Draw labels
  ctx.fillStyle = "#ffffff";
  ctx.fillText(text, x, y);
}

----- D:\chessweb\src\utils\render\renderCorners.tsx -----
import { drawPoints, setupCtx } from "./common"; 

export const renderCorners = (canvasRef: any, xCorners: number[][]) => {
  const [ctx, _, __, sx, sy] = setupCtx(canvasRef);

  drawPoints(ctx, xCorners, "blue", sx, sy);
}


----- D:\chessweb\src\utils\render\renderState.tsx -----
import { LABELS, PALETTE, MODEL_WIDTH, MODEL_HEIGHT } from "../constants";
import { setupCtx, drawBox, drawPoints, drawPolygon } from "./common";

interface StockfishMoveCoords {
  sourceCoord?: number[];
  destCoord?: number[];
  sourcePieceBaseCoord?: number[];
  capturedPieceBaseCoord?: number[];
  isCapture?: boolean;
  capturedSquare?: string;
  sourceSquare?: string;
}

export const renderState = (canvasRef: any, centers: number[][], boundary: number[][], state: number[][], stockfishMove?: StockfishMoveCoords) => {
  const [ctx, fontHeight, lineWidth, sx, sy] = setupCtx(canvasRef);

  console.log("DEBUG RENDER: Canvas size:", canvasRef.width, canvasRef.height);
  console.log("DEBUG RENDER: Scaling factors sx, sy:", sx, sy);
  console.log("DEBUG RENDER: Model dimensions:", MODEL_WIDTH, MODEL_HEIGHT);
  
  drawPoints(ctx, centers, "blue", sx, sy);
  drawPolygon(ctx, boundary, "blue", sx, sy);

  for (let i = 0; i < 64; i++) {
    let bestScore = 0.1;
    let bestPiece = -1;
    for (let j = 0; j < 12; j++) {
      if (state[i][j] > bestScore) {
        bestScore = state[i][j];
        bestPiece = j;
      }
    }

    if (bestPiece === -1) {
      continue;
    }
    
    const color = PALETTE[bestPiece % PALETTE.length];
    const text: string = `${LABELS[bestPiece]}:${Math.round(100 * bestScore)}`;

    drawBox(ctx, color, centers[i][0] * sx, centers[i][1] * sy, text, fontHeight, lineWidth);
  }

  // Draw stockfish move dots if available
  if (stockfishMove) {
    console.log("DEBUG RENDER: Stockfish move available:", stockfishMove);
    const { sourceCoord, destCoord, sourcePieceBaseCoord, capturedPieceBaseCoord, isCapture } = stockfishMove;
    
    // Draw source piece base (bright blue with black outline)
    if (sourcePieceBaseCoord && sourcePieceBaseCoord.length === 2) {
      const x = sourcePieceBaseCoord[0] * sx;
      const y = sourcePieceBaseCoord[1] * sy;
      console.log("DEBUG RENDER: Drawing piece base at (canvas):", x, y, "from model:", sourcePieceBaseCoord);
      
      // Draw a larger, more visible blue dot for piece base
      ctx.strokeStyle = '#000000'; // Black outline
      ctx.lineWidth = 3;
      ctx.fillStyle = '#0000FF'; // Bright blue for piece base
      ctx.beginPath();
      ctx.arc(x, y, 15, 0, Math.PI * 2); // Larger radius
      ctx.fill();
      ctx.stroke();
      
      // Draw label
      ctx.fillStyle = '#FFFFFF'; // White text
      ctx.font = 'bold 16px Arial';
      ctx.fillText('B', x - 4, y - 8);
    }
    
    // Draw captured piece base (orange with black outline) - only for captures
    if (isCapture && capturedPieceBaseCoord && capturedPieceBaseCoord.length === 2) {
      const x = capturedPieceBaseCoord[0] * sx;
      const y = capturedPieceBaseCoord[1] * sy;
      console.log("DEBUG RENDER: Drawing captured piece base at (canvas):", x, y, "from model:", capturedPieceBaseCoord);
      
      // Draw an orange dot for captured piece base
      ctx.strokeStyle = '#000000'; // Black outline
      ctx.lineWidth = 3;
      ctx.fillStyle = '#FFA500'; // Orange for captured piece base
      ctx.beginPath();
      ctx.arc(x, y, 15, 0, Math.PI * 2); // Larger radius
      ctx.fill();
      ctx.stroke();
      
      // Draw label
      ctx.fillStyle = '#000000'; // Black text for better contrast on orange
      ctx.font = 'bold 16px Arial';
      ctx.fillText('C', x - 4, y - 8);
    }
    
    // Draw source square (pink with black outline) - original behavior
    if (sourceCoord && sourceCoord.length === 2) {
      const x = sourceCoord[0] * sx;
      const y = sourceCoord[1] * sy;
      console.log("DEBUG RENDER: Drawing source square at (canvas):", x, y, "from model:", sourceCoord);
      
      // Draw a pink dot for square center
      ctx.strokeStyle = '#000000'; // Black outline
      ctx.lineWidth = 3;
      ctx.fillStyle = '#FF00FF'; // Bright pink
      ctx.beginPath();
      ctx.arc(x, y, 12, 0, Math.PI * 2); // Medium radius
      ctx.fill();
      ctx.stroke();
      
      // Draw label
      ctx.fillStyle = '#FFFFFF'; // White text
      ctx.font = 'bold 16px Arial';
      ctx.fillText('S', x - 4, y - 8);
    }
    
    // Draw destination dot (green with black outline)
    if (destCoord && destCoord.length === 2) {
      const x = destCoord[0] * sx;
      const y = destCoord[1] * sy;
      console.log("DEBUG RENDER: Drawing destination at (canvas):", x, y, "from model:", destCoord);
      
      // Draw a green dot for destination
      ctx.strokeStyle = '#000000'; // Black outline
      ctx.lineWidth = 3;
      ctx.fillStyle = '#00FF00'; // Bright green
      ctx.beginPath();
      ctx.arc(x, y, 12, 0, Math.PI * 2); // Medium radius
      ctx.fill();
      ctx.stroke();
      
      // Draw label
      ctx.fillStyle = '#FFFFFF'; // White text
      ctx.font = 'bold 16px Arial';
      ctx.fillText('D', x - 4, y - 8);
    }
  } else {
    console.log("DEBUG RENDER: No stockfish move to render");
  }
};

----- D:\chessweb\src\workers\droidcamWorker.js -----
// WebSocket connection for DroidCam - runs in separate thread
let ws = null;
let frameCount = 0;
let lastFrameTime = 0;

self.onmessage = function(e) {
  const { type, url } = e.data;
  
  switch(type) {
    case 'connect':
      connectWebSocket(url);
      break;
    case 'disconnect':
      if (ws) {
        ws.close();
        ws = null;
      }
      break;
    default:
      break;
  }
};

function connectWebSocket(url) {
  console.log('[Worker] Connecting to WebSocket:', url);
  
  ws = new WebSocket(url);
  
  ws.onopen = function() {
    console.log('[Worker] WebSocket connected');
    self.postMessage({ type: 'connected' });
    lastFrameTime = performance.now();
  };
  
  ws.onmessage = async function(event) {
    // Handle JSON metadata
    if (typeof event.data === 'string') {
      try {
        const data = JSON.parse(event.data);
        if (data.type === 'frame') {
          // We'll wait for binary data
        }
      } catch (e) {
        // Not JSON, ignore
      }
      return;
    }
    
    // Binary frame data
    frameCount++;
    
    // Calculate FPS
    const now = performance.now();
    const fps = Math.round(1000 / (now - lastFrameTime));
    lastFrameTime = now;
    
    // Convert to Blob
    let blob;
    if (event.data instanceof ArrayBuffer) {
      blob = new Blob([event.data], { type: 'image/jpeg' });
    } else {
      blob = event.data;
    }
    
    // Create ImageBitmap (off-thread operation)
    try {
      const imageBitmap = await createImageBitmap(blob);
      
      // Send frame back to main thread
      self.postMessage({
        type: 'frame',
        imageBitmap: imageBitmap,
        frameNumber: frameCount,
        fps: fps
      }, [imageBitmap]); // Transfer ImageBitmap (zero-copy)
      
    } catch (error) {
      console.error('[Worker] Error processing frame:', error);
    }
  };
  
  ws.onerror = function(error) {
    console.error('[Worker] WebSocket error:', error);
    self.postMessage({ type: 'error', error: error.message });
  };
  
  ws.onclose = function() {
    console.log('[Worker] WebSocket closed');
    self.postMessage({ type: 'closed' });
  };
}

----- D:\chessweb\public\robot_bridge_advanced.py -----
#!/usr/bin/env python3
"""
Advanced WebSocket bridge with proper OnRobot 2FG7 gripper control
Now with adjustable width settings and proper protocol compliance
"""
import asyncio
import websockets
import socket
import json
import time
import struct
import threading
from typing import Optional, Dict, Any, Tuple

# ===================================================================
# OnRobot 2FG7 Gripper Controller (Modbus TCP) - UPDATED
# ===================================================================
class OnRobotGripper:
    """Direct TCP Modbus communication for OnRobot 2FG7/2FG14 gripper"""
    
    def __init__(self, ip="192.168.1.1", port=502, unit_id=65):
        self.ip = ip
        self.port = port
        self.unit_id = unit_id
        self.sock = None
        self.transaction_id = 1
        self.lock = threading.Lock()
        self.connected = False
        self.product_code = None
        self.model_type = None
        self.model_limits = None  # Will store (min_width_mm, max_width_mm)
        self.is_2fg7 = False
        self.is_2fg14 = False
        
    def connect(self) -> bool:
        """Establish connection to Compute Box"""
        print(f"[GRIPPER] Connecting to {self.ip}:{self.port}...")
        
        try:
            with self.lock:
                if self.sock:
                    self.sock.close()
                
                self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                self.sock.settimeout(3.0)
                self.sock.connect((self.ip, self.port))
                self.connected = True
                
                # Read product code to identify the gripper
                self.product_code = self._read_holding_register(1536)
                if self.product_code:
                    print(f"[GRIPPER] âœ“ Connected! Product code: 0x{self.product_code:04X}")
                    
                    # Set model information based on product code
                    if self.product_code == 0xC0:  # 2FG7
                        self.model_type = "2FG7"
                        self.is_2fg7 = True
                        print(f"[GRIPPER] Type: 2FG7 (13-31mm)")
                    elif self.product_code == 0xC1:  # 2FG14
                        self.model_type = "2FG14"
                        self.is_2fg14 = True
                        print(f"[GRIPPER] Type: 2FG14 (22-48mm)")
                    elif self.product_code == 0xF0:  # 2FGP20
                        self.model_type = "2FGP20"
                        print(f"[GRIPPER] Type: 2FGP20")
                    else:
                        self.model_type = "Unknown"
                        print(f"[GRIPPER] Type: Unknown (0x{self.product_code:04X})")
                    
                    # Read actual hardware limits from the gripper
                    min_width_units = self._read_holding_register(259)  # Min external width
                    max_width_units = self._read_holding_register(260)  # Max external width
                    
                    if min_width_units is not None and max_width_units is not None:
                        min_width_mm = min_width_units / 10.0
                        max_width_mm = max_width_units / 10.0
                        self.model_limits = (min_width_mm, max_width_mm)
                        print(f"[GRIPPER] Actual limits: {min_width_mm}mm to {max_width_mm}mm")
                    else:
                        # Fallback to nominal limits based on model
                        if self.is_2fg7:
                            self.model_limits = (13.0, 31.0)
                        elif self.is_2fg14:
                            self.model_limits = (22.0, 48.0)
                        else:
                            self.model_limits = (0.0, 100.0)
                        print(f"[GRIPPER] Using nominal limits: {self.model_limits[0]}mm to {self.model_limits[1]}mm")
                        
                else:
                    print(f"[GRIPPER] âœ“ Connected but could not read product code")
                
                return True
                
        except Exception as e:
            print(f"[GRIPPER] âœ— Connection failed: {e}")
            self.connected = False
            return False
    
    def disconnect(self):
        """Close connection"""
        with self.lock:
            if self.sock:
                self.sock.close()
                self.sock = None
            self.connected = False
            print("[GRIPPER] Disconnected")
    
    def _send_modbus_request(self, function_code: int, data: bytes) -> Optional[bytes]:
        """Send raw Modbus TCP request and get response"""
        if not self.connected or not self.sock:
            return None
            
        try:
            # Increment transaction ID
            transaction_id = self.transaction_id
            self.transaction_id = (self.transaction_id + 1) % 65536
            
            # Build MBAP header (Modbus Application Protocol)
            length = len(data) + 1  # +1 for unit_id
            mbap_header = struct.pack('>HHHB', 
                                     transaction_id, 
                                     0,           # Protocol ID = 0 for Modbus
                                     length, 
                                     self.unit_id)
            
            # Build complete frame
            frame = mbap_header + data
            
            # Send request
            self.sock.sendall(frame)
            
            # Receive response header (7 bytes)
            header = self.sock.recv(7)
            if len(header) != 7:
                print(f"[GRIPPER] Invalid header length: {len(header)}")
                return None
            
            # Parse response header
            resp_trans_id, resp_proto_id, resp_length, resp_unit_id = struct.unpack('>HHHB', header)
            
            # Receive remaining data
            data_len = resp_length - 1  # Subtract unit_id byte
            if data_len > 0:
                response_data = self.sock.recv(data_len)
                if len(response_data) != data_len:
                    print(f"[GRIPPER] Incomplete data: got {len(response_data)}, expected {data_len}")
                    return None
            else:
                response_data = b''
            
            # Check if it's an exception response
            if response_data and response_data[0] == function_code + 0x80:
                exception_code = response_data[1]
                print(f"[GRIPPER] Modbus exception: code {exception_code}")
                return None
            
            return response_data
            
        except socket.timeout:
            print("[GRIPPER] Timeout sending/receiving data")
            return None
        except Exception as e:
            print(f"[GRIPPER] Communication error: {e}")
            return None
    
    def _read_holding_register(self, address: int) -> Optional[int]:
        """Read a single holding register (Function Code 0x03)"""
        pdu = struct.pack('>BHH', 0x03, address, 1)
        response = self._send_modbus_request(0x03, pdu)
        
        if response and len(response) >= 3:
            if response[0] == 0x03 and response[1] == 2:
                return struct.unpack('>H', response[2:4])[0]
        
        return None
    
    def _write_single_register(self, address: int, value: int) -> bool:
        """Write a single register (Function Code 0x06)"""
        pdu = struct.pack('>BHH', 0x06, address, value)
        response = self._send_modbus_request(0x06, pdu)
        
        if response and len(response) >= 5:
            return response[0] == 0x06
        
        return False
    
    def get_status(self) -> Dict[str, Any]:
        """Get comprehensive gripper status"""
        if not self.connected:
            return {"connected": False, "error": "Not connected"}
        
        # Read various status registers
        status_reg = self._read_holding_register(256)  # 0x0100 Status
        width_reg = self._read_holding_register(257)   # 0x0101 External width
        internal_width_reg = self._read_holding_register(258)  # 0x0102 Internal width
        min_reg = self._read_holding_register(259)     # 0x0103 Min external width
        max_reg = self._read_holding_register(260)     # 0x0104 Max external width
        min_internal_reg = self._read_holding_register(261)  # 0x0105 Min internal width
        max_internal_reg = self._read_holding_register(262)  # 0x0106 Max internal width
        force_reg = self._read_holding_register(263)   # 0x0107 Current force
        max_force_reg = self._read_holding_register(1029)  # 0x0405 Maximum force
        
        result = {
            "connected": self.connected,
            "product_code": self.product_code,
            "model_type": self.model_type,
            "width_mm": width_reg / 10.0 if width_reg is not None else None,
            "internal_width_mm": internal_width_reg / 10.0 if internal_width_reg is not None else None,
            "min_width_mm": min_reg / 10.0 if min_reg is not None else None,
            "max_width_mm": max_reg / 10.0 if max_reg is not None else None,
            "min_internal_width_mm": min_internal_reg / 10.0 if min_internal_reg is not None else None,
            "max_internal_width_mm": max_internal_reg / 10.0 if max_internal_reg is not None else None,
            "force_n": force_reg if force_reg is not None else None,
            "max_force_n": max_force_reg if max_force_reg is not None else None,
            "model_limits": self.model_limits,
        }
        
        # Decode status register bits
        if status_reg is not None:
            result.update({
                "busy": bool(status_reg & 0x0001),
                "grip_detected": bool(status_reg & 0x0002),
                "error_not_calibrated": bool(status_reg & 0x0008),
                "error_linear_sensor": bool(status_reg & 0x0010),
                "raw_status": status_reg,
            })
        
        return result
    
    def move_to_width(self, width_mm: float, force_n: int = 20, speed_percent: int = 50) -> bool:
        """Move gripper to a specific width (main function for both open/close)"""
        if not self.connected:
            print("[GRIPPER] Not connected")
            return False
        
        # Clamp speed to valid range (10-100%)
        speed_percent = max(10, min(100, speed_percent))
        
        # Convert width to gripper units (1/10 mm)
        target_width_units = int(width_mm * 10)
        
        print(f"[GRIPPER] Moving to {width_mm}mm ({target_width_units} units)...")
        
        # Check against hardware limits if available
        if self.model_limits:
            min_limit, max_limit = self.model_limits
            if width_mm < min_limit:
                print(f"[GRIPPER] Warning: {width_mm}mm below minimum {min_limit}mm, clamping to {min_limit}mm")
                width_mm = min_limit
                target_width_units = int(width_mm * 10)
            elif width_mm > max_limit:
                print(f"[GRIPPER] Warning: {width_mm}mm above maximum {max_limit}mm, clamping to {max_limit}mm")
                width_mm = max_limit
                target_width_units = int(width_mm * 10)
        
        # Set parameters according to protocol
        # Address 0x0000: Target width (in 1/10 mm units)
        if not self._write_single_register(0, target_width_units):
            print("[GRIPPER] Failed to set target width")
            return False
        
        # Address 0x0001: Target force (in N)
        if not self._write_single_register(1, force_n):
            print("[GRIPPER] Failed to set target force")
            return False
        
        # Address 0x0002: Target speed (in %, clamped to 10-100%)
        if not self._write_single_register(2, speed_percent):
            print("[GRIPPER] Failed to set target speed")
            return False
        
        # Address 0x0003: Command (1 = Grip external)
        if not self._write_single_register(3, 1):
            print("[GRIPPER] Failed to execute grip command")
            return False
        
        print(f"[GRIPPER] âœ“ Command sent: width={width_mm}mm, force={force_n}N, speed={speed_percent}%")
        return True
    
    def open(self, width_mm: Optional[float] = None, force_n: int = 20, speed_percent: int = 50) -> bool:
        """Open gripper to specified width"""
        if not self.connected:
            print("[GRIPPER] Not connected")
            return False
        
        # If no width specified, use default of 20mm
        if width_mm is None:
            width_mm = 20.0
        
        # Clamp speed
        speed_percent = max(10, min(100, speed_percent))
        
        print(f"[GRIPPER] Opening to {width_mm}mm...")
        return self.move_to_width(width_mm, force_n, speed_percent)
    
    def close(self, width_mm: Optional[float] = None, force_n: int = 20, speed_percent: int = 50) -> bool:
        """Close gripper to specified width"""
        if not self.connected:
            print("[GRIPPER] Not connected")
            return False
        
        # If no width specified, use default of 0.3mm
        if width_mm is None:
            width_mm = 0.3
        
        # Clamp speed
        speed_percent = max(10, min(100, speed_percent))
        
        print(f"[GRIPPER] Closing to {width_mm}mm...")
        return self.move_to_width(width_mm, force_n, speed_percent)
    
    def stop(self) -> bool:
        """Stop gripper movement"""
        if not self.connected:
            return False
        
        print("[GRIPPER] Stopping gripper...")
        # Address 0x0003: Command (3 = Stop)
        result = self._write_single_register(3, 3)
        if result:
            print("[GRIPPER] âœ“ Stopped")
        return result
    
    def set_finger_length(self, length_mm: float) -> bool:
        """Set finger length in 1/10 mm (Address 0x0400)"""
        if not self.connected:
            return False
        
        length_units = int(length_mm * 10)
        print(f"[GRIPPER] Setting finger length to {length_mm}mm ({length_units} units)...")
        return self._write_single_register(1024, length_units)
    
    def set_finger_height(self, height_mm: float) -> bool:
        """Set finger height in 1/10 mm (Address 0x0401)"""
        if not self.connected:
            return False
        
        height_units = int(height_mm * 10)
        print(f"[GRIPPER] Setting finger height to {height_mm}mm ({height_units} units)...")
        return self._write_single_register(1025, height_units)
    
    def set_finger_orientation(self, orientation: int) -> bool:
        """Set finger orientation (0 = inward, 1 = outward) (Address 0x0402)"""
        if not self.connected:
            return False
        
        if orientation not in [0, 1]:
            print(f"[GRIPPER] Invalid orientation: {orientation} (must be 0 or 1)")
            return False
        
        print(f"[GRIPPER] Setting finger orientation to {orientation}...")
        return self._write_single_register(1026, orientation)
    
    def set_fingertip_offset(self, offset_mm: float) -> bool:
        """Set fingertip offset in 1/100 mm (Address 0x0403)"""
        if not self.connected:
            return False
        
        offset_units = int(offset_mm * 100)
        print(f"[GRIPPER] Setting fingertip offset to {offset_mm}mm ({offset_units} units)...")
        return self._write_single_register(1027, offset_units)


# ===================================================================
# UR5 Robot Arm Controller (UNCHANGED)
# ===================================================================
class URRobotArm:
    """Controller for UR5 robot arm"""
    
    # Movement parameters from original bridge
    ACCELERATION = 0.3
    VELOCITY = 0.15
    MOVE_WAIT_TIME = 3.5      # seconds for clearance moves
    VERTICAL_WAIT_TIME = 1.0  # seconds for vertical moves
    RESTING_WAIT_TIME = 4.0   # seconds for resting position moves
    
    def __init__(self, ip="192.168.1.20", port=30002):
        self.ip = ip
        self.port = port
        self.socket = None
        self.connected = False
        
    def connect(self) -> bool:
        """Connect to UR5 robot"""
        print(f"[UR5] Connecting to {self.ip}:{self.port}...")
        
        try:
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.socket.settimeout(10)
            self.socket.connect((self.ip, self.port))
            self.connected = True
            
            # Test connection
            self._send_command("textmsg(\"WebSocket Bridge Connected\")")
            print(f"[UR5] âœ“ Connected to UR5 at {self.ip}:{self.port}")
            return True
            
        except Exception as e:
            print(f"[UR5] âœ— Connection failed: {e}")
            self.connected = False
            return False
    
    def disconnect(self):
        """Disconnect from robot"""
        if self.socket:
            self.socket.close()
            self.socket = None
        self.connected = False
        print("[UR5] Disconnected")
    
    def _send_command(self, command: str, wait_time: float = 0.1) -> bool:
        """Send command to UR5"""
        if not self.connected or not self.socket:
            print("[UR5] Not connected")
            return False
        
        try:
            full_cmd = command + "\n"
            self.socket.sendall(full_cmd.encode())
            time.sleep(wait_time)
            return True
        except Exception as e:
            print(f"[UR5] Command failed: {e}")
            self.connected = False
            return False
    
    def move_to_pose(self, pose: Dict[str, float], move_type: str = "clearance") -> bool:
        """Move to a specific pose"""
        if not self.connected:
            return False
        
        # Determine wait time based on move type
        if move_type == "vertical":
            wait_time = self.VERTICAL_WAIT_TIME
            # Use movel for vertical moves (linear, precise)
            cmd = (f"movel(p[{pose['x']:.5f}, {pose['y']:.5f}, {pose['z']:.5f}, "
                   f"{pose['rx']:.5f}, {pose['ry']:.5f}, {pose['rz']:.5f}], "
                   f"a={self.ACCELERATION}, v={self.VELOCITY})")
        else:
            wait_time = self.MOVE_WAIT_TIME if move_type == "clearance" else self.RESTING_WAIT_TIME
            # Use movej for clearance/resting moves (fast, joint space)
            cmd = (f"movej(p[{pose['x']:.5f}, {pose['y']:.5f}, {pose['z']:.5f}, "
                   f"{pose['rx']:.5f}, {pose['ry']:.5f}, {pose['rz']:.5f}], "
                   f"a={self.ACCELERATION}, v={self.VELOCITY})")
        
        # Send command
        if not self._send_command(cmd):
            return False
        
        # Wait for move to complete
        print(f"[UR5] â±ï¸  Waiting {wait_time:.1f}s for {move_type} move...")
        time.sleep(wait_time)
        
        print(f"[UR5] âœ“ Move completed: {move_type}")
        return True
    
    def get_status(self) -> Dict[str, Any]:
        """Get robot arm status"""
        return {
            "connected": self.connected,
            "ip": self.ip,
            "port": self.port
        }


# ===================================================================
# Combined Robot System Controller (UPDATED for width control)
# ===================================================================
class RobotSystem:
    """Combines UR5 arm and OnRobot gripper with enhanced width control"""
    
    def __init__(self):
        self.arm = URRobotArm()
        self.gripper = OnRobotGripper()
        self.connected = False
        self.last_open_width = None
        self.last_close_width = None
        
    def connect(self) -> bool:
        """Connect to both arm and gripper"""
        print("=" * 60)
        print("ðŸ¤– ROBOT SYSTEM STARTUP")
        print("=" * 60)
        
        # Connect to gripper first
        print("\n1. Connecting to OnRobot 2FG7 Gripper...")
        gripper_ok = self.gripper.connect()
        
        if not gripper_ok:
            print("[SYSTEM] âŒ Gripper connection failed - check power, IP (192.168.1.1), and network")
            return False
        
        # Connect to arm
        print("\n2. Connecting to UR5 Robot Arm...")
        arm_ok = self.arm.connect()
        
        if not arm_ok:
            print("[SYSTEM] âŒ Arm connection failed - check power, IP (192.168.1.20), and network")
            return False
        
        self.connected = True
        print("\n" + "=" * 60)
        print("âœ… SYSTEM READY: Both arm and gripper connected!")
        print("=" * 60)
        return True
    
    def disconnect(self):
        """Disconnect from both devices"""
        print("[SYSTEM] Disconnecting...")
        self.arm.disconnect()
        self.gripper.disconnect()
        self.connected = False
        print("[SYSTEM] Disconnected")
    
    def execute_move(self, pose: Dict[str, float], move_type: str = "clearance") -> bool:
        """Execute a robot move"""
        if not self.connected:
            return False
        return self.arm.move_to_pose(pose, move_type)
    
    def execute_gripper(self, action: str, width_mm: Optional[float] = None, 
                       force_n: int = 20, speed_percent: int = 50) -> bool:
        """Execute gripper action with optional width specification"""
        if not self.connected:
            return False
        
        if action == "open":
            success = self.gripper.open(width_mm, force_n, speed_percent)
            if success and width_mm is not None:
                self.last_open_width = width_mm
            return success
        elif action == "close":
            success = self.gripper.close(width_mm, force_n, speed_percent)
            if success and width_mm is not None:
                self.last_close_width = width_mm
            return success
        elif action == "stop":
            return self.gripper.stop()
        elif action == "move_to_width":
            if width_mm is None:
                print("[SYSTEM] Error: Width must be specified for move_to_width action")
                return False
            return self.gripper.move_to_width(width_mm, force_n, speed_percent)
        else:
            print(f"[SYSTEM] Unknown gripper action: {action}")
            return False
    
    def get_status(self) -> Dict[str, Any]:
        """Get complete system status"""
        gripper_status = self.gripper.get_status()
        gripper_status.update({
            "last_open_width": self.last_open_width,
            "last_close_width": self.last_close_width,
        })
        
        return {
            "connected": self.connected,
            "arm": self.arm.get_status(),
            "gripper": gripper_status
        }


# ===================================================================
# WebSocket Bridge Server (UPDATED for width control)
# ===================================================================
class WebSocketBridge:
    """WebSocket server for robot control with width adjustment"""
    
    def __init__(self):
        self.robot = RobotSystem()
        self.clients = set()
    
    async def handle_client(self, websocket):
        """Handle a WebSocket client connection"""
        client_id = id(websocket)
        print(f"\n[WS] ðŸ”Œ New client connected: {client_id}")
        self.clients.add(websocket)
        
        try:
            # Send welcome message
            welcome = {
                "type": "welcome",
                "message": "Robot WebSocket Bridge Connected",
                "timestamp": time.time(),
                "system": "UR5 + OnRobot 2FG7/2FG14",
                "gripper_ip": "192.168.1.1:502",
                "arm_ip": "192.168.1.20:30002",
                "features": ["width_adjustment", "force_control", "speed_control"]
            }
            await websocket.send(json.dumps(welcome))
            
            # Main message loop
            async for message in websocket:
                try:
                    data = json.loads(message)
                    print(f"[WS] ðŸ“¥ From {client_id}: {json.dumps(data)}")
                    
                    # Handle different message types
                    response = await self._handle_message(data)
                    if response:
                        await websocket.send(json.dumps(response))
                        
                except json.JSONDecodeError:
                    error = {"type": "error", "message": "Invalid JSON"}
                    await websocket.send(json.dumps(error))
                except Exception as e:
                    error = {"type": "error", "message": f"Processing error: {str(e)}"}
                    await websocket.send(json.dumps(error))
                    
        except websockets.exceptions.ConnectionClosed:
            print(f"[WS] ðŸ”Œ Client disconnected: {client_id}")
        finally:
            self.clients.remove(websocket)
    
    async def _handle_message(self, data: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Handle incoming WebSocket messages"""
        msg_type = data.get("type")
        
        if msg_type == "connect":
            # Connect to robot system
            if self.robot.connect():
                status = self.robot.get_status()
                return {
                    "type": "connected",
                    "message": "Robot system connected successfully",
                    "status": status
                }
            else:
                return {
                    "type": "error",
                    "message": "Failed to connect to robot system"
                }
        
        elif msg_type == "disconnect":
            # Disconnect from robot system
            self.robot.disconnect()
            return {
                "type": "disconnected",
                "message": "Robot system disconnected"
            }
        
        elif msg_type == "status":
            # Get system status
            return {
                "type": "status",
                "status": self.robot.get_status(),
                "timestamp": time.time()
            }
        
        elif msg_type == "move":
            # Execute robot move
            pose = data.get("pose")
            move_type = data.get("moveType", "clearance")
            
            if not pose:
                return {"type": "error", "message": "No pose provided"}
            
            if not self.robot.connected:
                return {"type": "error", "message": "Robot not connected"}
            
            success = self.robot.execute_move(pose, move_type)
            if success:
                return {
                    "type": "move_complete",
                    "message": f"Move completed: {move_type}",
                    "pose": pose,
                    "move_type": move_type
                }
            else:
                return {
                    "type": "error",
                    "message": "Move failed"
                }
        
        elif msg_type == "gripper":
            # Execute gripper action with optional parameters
            action = data.get("action")
            width_mm = data.get("width_mm")
            force_n = data.get("force_n", 20)
            speed_percent = data.get("speed_percent", 50)
            
            if action not in ["open", "close", "stop", "move_to_width"]:
                return {"type": "error", "message": f"Invalid gripper action: {action}"}
            
            if action == "move_to_width" and width_mm is None:
                return {"type": "error", "message": "Width must be specified for move_to_width"}
            
            if not self.robot.connected:
                return {"type": "error", "message": "Robot not connected"}
            
            success = self.robot.execute_gripper(action, width_mm, force_n, speed_percent)
            if success:
                return {
                    "type": "gripper_complete",
                    "message": f"Gripper {action} completed",
                    "action": action,
                    "width_mm": width_mm,
                    "force_n": force_n,
                    "speed_percent": speed_percent
                }
            else:
                return {
                    "type": "error",
                    "message": f"Gripper {action} failed"
                }
        
        elif msg_type == "set_gripper_config":
            # Set gripper configuration parameters
            if not self.robot.connected:
                return {"type": "error", "message": "Robot not connected"}
            
            # Get the gripper object
            gripper = self.robot.gripper
            
            # Apply configuration if provided
            success = True
            messages = []
            
            if "finger_length_mm" in data:
                if gripper.set_finger_length(data["finger_length_mm"]):
                    messages.append(f"Finger length set to {data['finger_length_mm']}mm")
                else:
                    success = False
                    messages.append("Failed to set finger length")
            
            if "finger_height_mm" in data:
                if gripper.set_finger_height(data["finger_height_mm"]):
                    messages.append(f"Finger height set to {data['finger_height_mm']}mm")
                else:
                    success = False
                    messages.append("Failed to set finger height")
            
            if "finger_orientation" in data:
                if gripper.set_finger_orientation(data["finger_orientation"]):
                    orientation = "inward" if data["finger_orientation"] == 0 else "outward"
                    messages.append(f"Finger orientation set to {orientation}")
                else:
                    success = False
                    messages.append("Failed to set finger orientation")
            
            if "fingertip_offset_mm" in data:
                if gripper.set_fingertip_offset(data["fingertip_offset_mm"]):
                    messages.append(f"Fingertip offset set to {data['fingertip_offset_mm']}mm")
                else:
                    success = False
                    messages.append("Failed to set fingertip offset")
            
            if success:
                return {
                    "type": "config_set",
                    "message": "Gripper configuration updated",
                    "details": messages
                }
            else:
                return {
                    "type": "error",
                    "message": "Some configuration updates failed",
                    "details": messages
                }
        
        elif msg_type == "test":
            # Test command
            return {
                "type": "test_response",
                "message": "Test successful",
                "received": data,
                "timestamp": time.time()
            }
        
        else:
            return {
                "type": "error",
                "message": f"Unknown message type: {msg_type}"
            }
    
    async def run(self, host="localhost", port=8765):
        """Run the WebSocket server"""
        print("\n" + "=" * 60)
        print("ðŸš€ WEB SOCKET ROBOT BRIDGE WITH WIDTH CONTROL")
        print("=" * 60)
        print(f"ðŸ“¡ Listening on: ws://{host}:{port}")
        print("ðŸ¤– Supported commands:")
        print("  â€¢ connect - Connect to robot system")
        print("  â€¢ disconnect - Disconnect from robot system")
        print("  â€¢ status - Get system status")
        print("  â€¢ move - Move robot arm (with pose and moveType)")
        print("  â€¢ gripper - Control gripper (open/close/stop/move_to_width)")
        print("  â€¢ set_gripper_config - Set gripper parameters")
        print("  â€¢ test - Test command")
        print("\nðŸ’¡ Example gripper commands:")
        print('  {"type": "gripper", "action": "open", "width_mm": 20.0, "force_n": 20, "speed_percent": 50}')
        print('  {"type": "gripper", "action": "close", "width_mm": 0.3, "force_n": 20, "speed_percent": 50}')
        print('  {"type": "gripper", "action": "move_to_width", "width_mm": 15.0, "force_n": 20, "speed_percent": 50}')
        print("=" * 60 + "\n")
        
        server = await websockets.serve(self.handle_client, host, port)
        await server.wait_closed()


# ===================================================================
# Main Entry Point
# ===================================================================
async def main():
    """Main function to run the bridge"""
    bridge = WebSocketBridge()
    await bridge.run()


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\n\nðŸ‘‹ Bridge shutdown by user")
    except Exception as e:
        print(f"\nâŒ Fatal error: {e}")


----- D:\chessweb\robotkeyboardcontrol.py -----
import socket
import time
import threading
import struct
import json
import os
from pynput import keyboard

# ================== CONFIG ==================
ROBOT_IP = "192.168.1.20"
PORT = 30002

# Gripper config
GRIPPER_IP = "192.168.1.1"
GRIPPER_PORT = 502
GRIPPER_UNIT_ID = 65

# Pose file path - UPDATE THIS TO YOUR ACTUAL PATH
POSE_FILE_PATH = r"C:\Users\wunna\Downloads\chesswebcammaintransferfile\public\chessboard_poses.json"

# Movement parameters
MAX_LIN_SPEED = 0.05      # m/s
MAX_ROT_SPEED = 0.3       # rad/s
ACCELERATION = 0.2
SPEEDL_TIME = 10.0
LOOP_RATE = 0.02

# Pose movement parameters - SIMPLIFIED
POSE_ACCELERATION = 0.3
POSE_VELOCITY = 0.15
POSE_WAIT_TIME = 3.0      # Wait 5 seconds after sending move command
# ============================================

velocity = [0, 0, 0, 0, 0, 0]
last_sent_velocity = [0, 0, 0, 0, 0, 0]
vel_lock = threading.Lock()
running = True
gripper_busy = False
gripper_lock = threading.Lock()

# State variables for pose movement
pose_moving = False
cancel_pose_move = False
current_pose_target = None
poses = {}

# ================= KEY MAP ==================
KEY_MAP = {
    'w': (0, +1), 's': (0, -1),
    'a': (1, +1), 'd': (1, -1),
    'q': (2, +1), 'e': (2, -1),
    'i': (3, +1), 'k': (3, -1),
    'j': (4, +1), 'l': (4, -1),
    'u': (5, +1), 'o': (5, -1),
    # Gripper keys
    'g': 'close',  # Close gripper
    'h': 'open',   # Open gripper
    'y': 'stop',   # Stop gripper
    # Pose movement keys (will be handled separately)
    '1': 'pose1', '2': 'pose2', '3': 'pose3',
    '4': 'pose4', '5': 'pose5', '6': 'pose6',
    # Optional: add home and drop poses if they exist in JSON
    '7': 'home', '8': 'drop',
}
# ============================================

def load_poses():
    """Load poses from JSON file"""
    global poses
    if not os.path.exists(POSE_FILE_PATH):
        print(f"âš ï¸  Pose file not found: {POSE_FILE_PATH}")
        print("âš ï¸  Pose movement keys (1-6) will not work")
        return False
    
    try:
        with open(POSE_FILE_PATH, 'r') as f:
            poses = json.load(f)
        print(f"âœ“ Loaded poses from {POSE_FILE_PATH}")
        
        # List available poses
        if 'corners' in poses:
            print(f"  - {len(poses['corners'])} corners available")
            for i, corner in enumerate(poses['corners']):
                print(f"    {i+1}: [{corner['x']:.3f}, {corner['y']:.3f}, {corner['z']:.3f}]")
        if 'home' in poses:
            print("  - Home pose available")
        if 'drop' in poses:
            print("  - Drop pose available")
            
        return True
    except Exception as e:
        print(f"âœ— Error loading poses: {e}")
        return False

class SimpleGripperControl:
    """Direct TCP Modbus communication for OnRobot 2FG7 Gripper"""
    
    def __init__(self, ip=GRIPPER_IP, port=GRIPPER_PORT, unit_id=GRIPPER_UNIT_ID):
        self.ip = ip
        self.port = port
        self.unit_id = unit_id
        self.sock = None
        self.transaction_id = 1
        self.connected = False
        self.last_command = None
        
    def connect(self):
        """Establish connection to Compute Box"""
        try:
            if self.sock:
                self.sock.close()
            
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.settimeout(2.0)
            self.sock.connect((self.ip, self.port))
            self.connected = True
            print(f"âœ“ Gripper connected to {self.ip}:{self.port}")
            return True
        except Exception as e:
            print(f"âœ— Gripper connection error: {e}")
            self.connected = False
            return False
    
    def disconnect(self):
        """Close connection"""
        if self.sock:
            self.sock.close()
            self.sock = None
            self.connected = False
            print("Gripper disconnected")
    
    def _send_modbus_request(self, function_code, data):
        """Send raw Modbus TCP request and get response"""
        if not self.sock or not self.connected:
            return None
            
        try:
            # Increment transaction ID
            transaction_id = self.transaction_id
            self.transaction_id = (self.transaction_id + 1) % 65536
            
            # Build MBAP header
            length = len(data) + 1  # +1 for unit_id
            mbap_header = struct.pack('>HHHB', 
                                     transaction_id, 
                                     0,           # Protocol ID = 0 for Modbus
                                     length, 
                                     self.unit_id)
            
            # Build complete frame
            frame = mbap_header + data
            
            # Send request
            self.sock.sendall(frame)
            
            # Receive response header (7 bytes)
            header = self.sock.recv(7)
            if len(header) != 7:
                return None
            
            # Parse response header
            resp_trans_id, resp_proto_id, resp_length, resp_unit_id = struct.unpack('>HHHB', header)
            
            # Receive remaining data
            data_len = resp_length - 1  # Subtract unit_id byte
            if data_len > 0:
                response_data = self.sock.recv(data_len)
                if len(response_data) != data_len:
                    return None
            else:
                response_data = b''
            
            # Check if it's an exception response
            if response_data[0] == function_code + 0x80:
                return None
            
            return response_data
            
        except Exception:
            self.connected = False
            return None
    
    def read_holding_register(self, address):
        """Read a single holding register (Function Code 0x03)"""
        if not self.connected:
            return None
            
        # Build PDU: Function Code (1), Address (2), Quantity (2)
        pdu = struct.pack('>BHH', 0x03, address, 1)
        
        response = self._send_modbus_request(0x03, pdu)
        if response and len(response) >= 3:
            # Response format: FC (1), Byte Count (1), Data (2*N)
            if response[0] == 0x03 and response[1] == 2:
                value = struct.unpack('>H', response[2:4])[0]
                return value
        
        return None
    
    def write_single_register(self, address, value):
        """Write a single register (Function Code 0x06)"""
        if not self.connected:
            return False
            
        # Build PDU: Function Code (1), Address (2), Value (2)
        pdu = struct.pack('>BHH', 0x06, address, value)
        
        response = self._send_modbus_request(0x06, pdu)
        if response and len(response) >= 5:
            # Response should echo the request
            if response[0] == 0x06:
                return True
        
        return False
    
    def get_current_width(self):
        """Get current external width in mm"""
        value = self.read_holding_register(257)  # 0x0101 External width
        if value is not None:
            return value / 10.0  # Convert from 1/10 mm to mm
        return None
    
    def get_limits(self):
        """Get min and max width in mm"""
        min_val = self.read_holding_register(259)  # 0x0103 Min external width
        max_val = self.read_holding_register(260)  # 0x0104 Max external width
        
        if min_val is not None and max_val is not None:
            return min_val/10.0, max_val/10.0  # Convert to mm
        return None, None
    
    def get_status(self):
        """Get gripper status"""
        value = self.read_holding_register(256)  # 0x0100 Status
        if value is not None:
            return {
                'busy': bool(value & 0x0001),
                'grip_detected': bool(value & 0x0002),
                'error_not_calibrated': bool(value & 0x0008),
                'error_linear_sensor': bool(value & 0x0010)
            }
        return None
    
    def set_gripper_parameters(self, width_mm, force_n=20, speed_percent=50):
        """Set gripper parameters"""
        if not self.connected:
            return False
            
        # Convert width to 1/10 mm
        width_units = int(width_mm * 10)
        
        # Set parameters with error checking
        success = True
        if not self.write_single_register(0, width_units):    # Target width
            success = False
        if not self.write_single_register(1, force_n):        # Target force
            success = False
        if not self.write_single_register(2, speed_percent):  # Target speed
            success = False
        
        return success
    
    def execute_command(self, command):
        """Execute gripper command (1=grip external, 2=grip internal, 3=stop)"""
        if not self.connected:
            return False
        return self.write_single_register(3, command)
    
    def full_open(self, force_n=20, speed_percent=50):
        """Open gripper to maximum width"""
        min_width, max_width = self.get_limits()
        if max_width is None:
            print("âœ— Could not read max width")
            return False
        
        # Set parameters
        if self.set_gripper_parameters(max_width, force_n, speed_percent):
            time.sleep(0.1)  # Small delay
            if self.execute_command(1):  # Grip external command
                self.last_command = 'open'
                print(f"âœ“ Opening to {max_width}mm")
                return True
        
        print("âœ— Failed to open gripper")
        return False
    
    def full_close(self, force_n=20, speed_percent=50):
        """Close gripper to minimum width"""
        min_width, max_width = self.get_limits()
        if min_width is None:
            print("âœ— Could not read min width")
            return False
        
        # Set parameters
        if self.set_gripper_parameters(min_width, force_n, speed_percent):
            time.sleep(0.1)  # Small delay
            if self.execute_command(1):  # Grip external command
                self.last_command = 'close'
                print(f"âœ“ Closing to {min_width}mm")
                return True
        
        print("âœ— Failed to close gripper")
        return False
    
    def stop(self):
        """Stop gripper movement"""
        if not self.connected:
            return False
        result = self.execute_command(3)
        if result:
            print("âœ“ Gripper stopped")
        return result

def velocities_equal(v1, v2, eps=1e-4):
    return all(abs(a - b) < eps for a, b in zip(v1, v2))


class URJogController:
    def __init__(self, ip, port):
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.connect((ip, port))
        self.sock.sendall(b'textmsg("Keyboard jog connected")\n')
        
    def send(self, cmd):
        """Send command to robot"""
        self.sock.sendall((cmd + "\n").encode())
        
    def send_movel(self, pose, pose_name=""):
        """Send movel command to specific pose"""
        cmd = (f"movel(p[{pose['x']:.5f}, {pose['y']:.5f}, {pose['z']:.5f}, "
               f"{pose['rx']:.5f}, {pose['ry']:.5f}, {pose['rz']:.5f}], "
               f"a={POSE_ACCELERATION}, v={POSE_VELOCITY})")
        
        if pose_name:
            self.send(f'textmsg("Moving to {pose_name}")')
        self.send(cmd)
        
    def move_to_pose(self, pose, pose_name=""):
        """Send move command and wait fixed time"""
        global pose_moving, cancel_pose_move
        
        if pose_name:
            print(f"âž¡ï¸  Moving to {pose_name}...")
        
        pose_moving = True
        cancel_pose_move = False
        
        # Send the movement command
        self.send_movel(pose, pose_name)
        
        # SIMPLE APPROACH: Just wait 5 seconds
        # The robot will reach the position and stop automatically
        wait_time = POSE_WAIT_TIME
        step = 0.1  # Check for cancellation every 0.1 seconds
        
        for i in range(int(wait_time / step)):
            if cancel_pose_move:
                print(f"âš ï¸  {pose_name} movement cancelled!")
                self.send("stopl(0.5)")
                break
            time.sleep(step)
        else:
            if not cancel_pose_move:
                print(f"âœ“ {pose_name} movement complete (waited {POSE_WAIT_TIME}s)")
        
        pose_moving = False
        cancel_pose_move = False
        
    def loop(self):
        """Main control loop for continuous velocity control"""
        global last_sent_velocity, pose_moving
        
        while running:
            # If we're in the middle of a pose move, skip velocity control
            if pose_moving:
                time.sleep(LOOP_RATE)
                continue
                
            with vel_lock:
                v = velocity.copy()

            if not velocities_equal(v, last_sent_velocity):
                if any(abs(x) > 1e-4 for x in v):
                    cmd = (
                        f"speedl([{v[0]:.4f},{v[1]:.4f},{v[2]:.4f},"
                        f"{v[3]:.4f},{v[4]:.4f},{v[5]:.4f}],"
                        f"a={ACCELERATION},t={SPEEDL_TIME})"
                    )
                else:
                    cmd = "stopl(0.5)"

                self.send(cmd)
                last_sent_velocity = v

            time.sleep(LOOP_RATE)

        self.send("stopl(0.5)")
        self.sock.close()


def gripper_command_thread(command_type, gripper):
    """Thread function for gripper commands"""
    global gripper_busy
    
    with gripper_lock:
        if gripper_busy:
            print(f"âš  Gripper is busy. Ignoring {command_type} command.")
            return
        
        gripper_busy = True
    
    try:
        if command_type == 'open':
            gripper.full_open()
        elif command_type == 'close':
            gripper.full_close()
        elif command_type == 'stop':
            gripper.stop()
    except Exception as e:
        print(f"âœ— Gripper error during {command_type}: {e}")
    finally:
        with gripper_lock:
            gripper_busy = False


def pose_move_thread(pose_key, controller):
    """Thread function for pose movement"""
    global pose_moving, cancel_pose_move, poses
    
    # Map key to pose
    pose_mapping = {
        '1': ('corner1', 'corners', 0),
        '2': ('corner2', 'corners', 1),
        '3': ('corner3', 'corners', 2),
        '4': ('corner4', 'corners', 3),
        '5': ('corner5', 'corners', 4),
        '6': ('corner6', 'corners', 5),
        '7': ('home', 'home', 0),
        '8': ('drop', 'drop', 0),
    }
    
    if pose_key not in pose_mapping:
        print(f"âŒ Unknown pose key: {pose_key}")
        return
    
    pose_name, pose_type, index = pose_mapping[pose_key]
    
    # Get the pose from loaded poses
    if pose_type == 'corners':
        if 'corners' not in poses or index >= len(poses['corners']):
            print(f"âŒ Corner {index+1} not available in poses")
            return
        target_pose = poses['corners'][index]
    else:  # home or drop
        if pose_type not in poses:
            print(f"âŒ {pose_type.capitalize()} pose not available")
            return
        target_pose = poses[pose_type]
    
    # Start the pose movement
    controller.move_to_pose(target_pose, pose_name)


def on_press(key, gripper, controller):
    global gripper_busy, cancel_pose_move, pose_moving
    
    try:
        k = key.char.lower()
        
        # Check if pose movement is active and movement key is pressed
        if pose_moving and k in ['w', 's', 'a', 'd', 'q', 'e', 'i', 'k', 'j', 'l', 'u', 'o']:
            print("âš ï¸  Cancelling pose movement for manual control...")
            cancel_pose_move = True
            # Also set velocity for immediate manual control
            axis, direction = KEY_MAP[k]
            with vel_lock:
                if axis < 3:
                    velocity[axis] = direction * MAX_LIN_SPEED
                else:
                    velocity[axis] = direction * MAX_ROT_SPEED
            return
        
        if k in KEY_MAP:
            action = KEY_MAP[k]
            
            # Handle gripper commands
            if isinstance(action, str):
                if action in ['close', 'open', 'stop']:
                    # Start gripper command in separate thread
                    threading.Thread(target=gripper_command_thread, 
                                   args=(action, gripper), 
                                   daemon=True).start()
                elif action.startswith('pose') or action in ['home', 'drop']:
                    # Handle pose movement commands
                    if pose_moving:
                        print("âš ï¸  Already moving to a pose. Wait or cancel with movement key.")
                    else:
                        threading.Thread(target=pose_move_thread,
                                       args=(k, controller),
                                       daemon=True).start()
            else:
                # Handle robot movement keys
                axis, direction = action
                with vel_lock:
                    if axis < 3:
                        velocity[axis] = direction * MAX_LIN_SPEED
                    else:
                        velocity[axis] = direction * MAX_ROT_SPEED
                        
    except AttributeError:
        if key == keyboard.Key.esc:
            return False


def on_release(key):
    try:
        k = key.char.lower()
        if k in KEY_MAP:
            action = KEY_MAP[k]
            # Only reset velocity for movement keys
            if isinstance(action, tuple):
                axis, _ = action
                with vel_lock:
                    velocity[axis] = 0.0
    except AttributeError:
        pass


# ================= MAIN ==================
print("\n" + "="*60)
print("ðŸ¤– UR3 Keyboard Control with Pose Movement")
print("="*60)
print("\nðŸ“Œ Robot Movement (Continuous):")
print("  W/S: Forward/Backward  A/D: Left/Right  Q/E: Up/Down")
print("  I/K: Pitch             J/L: Yaw         U/O: Roll")
print("\nðŸŽ¯ Pose Movement (Discrete):")
print("  1-6: Move to saved corners 1-6")
print("  7: Move to Home pose       8: Move to Drop pose")
print("\nðŸ¤– Gripper Control:")
print("  G: Close Gripper       H: Open Gripper  Y: Stop Gripper")
print("\nâ¹ï¸  Controls:")
print("  ESC: Quit program")
print("  Movement keys during pose move: Cancel pose move")
print("  Note: Pose moves wait 5 seconds after sending command")
print("="*60 + "\n")

# Load poses from JSON file
pose_loaded = load_poses()

# Initialize and connect to robot
controller = URJogController(ROBOT_IP, PORT)

# Initialize and connect to gripper
gripper = SimpleGripperControl()
gripper_connected = False

print("ðŸ”Œ Connecting to gripper...")
if gripper.connect():
    gripper_connected = True
    # Verify connection by reading product info
    product_code = gripper.read_holding_register(1536)
    if product_code:
        if product_code == 0xC0:
            print("âœ“ Gripper: 2FG7 (13-31mm) detected")
        elif product_code == 0xC1:
            print("âœ“ Gripper: 2FG14 (22-48mm) detected")
        else:
            print(f"âœ“ Unknown gripper type detected (code: {product_code})")
    else:
        print("âš  Gripper connected but couldn't read product info")
else:
    print("âš  Gripper not connected. Gripper commands will be ignored.")

# Start robot control thread
robot_thread = threading.Thread(target=controller.loop, daemon=True)
robot_thread.start()

# Create keyboard listener with gripper and controller as arguments
listener = keyboard.Listener(
    on_press=lambda key: on_press(key, gripper, controller),
    on_release=on_release
)
listener.start()

print("âœ… Ready for control. Press ESC to exit.")
print("â„¹ï¸  Tip: Press any movement key (WASD, etc.) during pose movement to cancel it.")
print(f"â„¹ï¸  Pose moves: Send command â†’ Robot moves â†’ Wait {POSE_WAIT_TIME}s â†’ Ready\n")

# Keep main thread alive
try:
    while listener.running:
        time.sleep(0.1)
except KeyboardInterrupt:
    pass
finally:
    running = False
    if gripper_connected:
        gripper.disconnect()
    
    # Wait for threads to finish
    robot_thread.join(timeout=1.0)
    listener.stop()
    
    print("\nðŸ›‘ Disconnected cleanly")


----- D:\chessweb\simple-proxy.mjs -----
import express from 'express';
import cors from 'cors';
import http from 'http';
import WebSocket, { WebSocketServer } from 'ws';

const app = express();
app.use(cors());

const DROIDCAM_HOST = '192.168.18.4';
const DROIDCAM_PORT = 4747;
const DROIDCAM_PATH = '/video';

/* --------------------------------------------------
   CORS SETUP
-------------------------------------------------- */
app.use(cors({
  origin: '*',
  methods: ['GET', 'POST', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'Range'],
  exposedHeaders: ['Content-Length', 'Content-Range']
}));

app.options('*', (req, res) => {
  res.set({
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization, Range',
    'Access-Control-Expose-Headers': 'Content-Length, Content-Range',
    'Access-Control-Max-Age': '86400'
  });
  res.sendStatus(204);
});

/* --------------------------------------------------
   MJPEG STREAM PROXY (for display)
-------------------------------------------------- */
app.get('/video', (req, res) => {
  console.log('ðŸ“¡ Display stream requested');
  
  const droidcamReq = http.request({
    host: DROIDCAM_HOST,
    port: DROIDCAM_PORT,
    path: DROIDCAM_PATH,
    method: 'GET',
    headers: {
      'User-Agent': 'MJPEG-Proxy',
      'Accept': 'multipart/x-mixed-replace'
    }
  }, (droidcamRes) => {
    res.writeHead(200, {
      'Content-Type': droidcamRes.headers['content-type'] || 'multipart/x-mixed-replace',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
      'Access-Control-Allow-Origin': '*'
    });
    
    droidcamRes.pipe(res);
    
    droidcamRes.on('end', () => {
      console.log('âš ï¸ Display stream ended');
      res.end();
    });
  });
  
  droidcamReq.on('error', (err) => {
    console.error('âŒ Display stream error:', err.message);
    if (!res.headersSent) {
      res.status(502).json({ error: err.message });
    }
  });
  
  req.on('close', () => {
    console.log('âŒ Display client disconnected');
    droidcamReq.destroy();
  });
  
  droidcamReq.end();
});

/* --------------------------------------------------
   HEALTH
-------------------------------------------------- */
app.get('/health', (_, res) => {
  res.json({
    status: 'ok',
    mode: 'real-time binary streaming',
    endpoints: {
      display: '/video',
      websocket: 'ws://localhost:8080'
    }
  });
});

/* --------------------------------------------------
   CREATE HTTP SERVER
-------------------------------------------------- */
const server = http.createServer(app);

/* --------------------------------------------------
   WEBSOCKET SERVER FOR REAL-TIME BINARY STREAMING
-------------------------------------------------- */
const wss = new WebSocketServer({ server });

// Store active DroidCam connection
let droidcamConnection = null;
let frameCount = 0;

wss.on('connection', (ws) => {
  console.log('ðŸ”Œ WebSocket client connected');
  
  // Close any existing DroidCam connection
  if (droidcamConnection) {
    droidcamConnection.destroy();
    droidcamConnection = null;
  }
  
  // Set up DroidCam connection
  const droidcamReq = http.request({
    host: DROIDCAM_HOST,
    port: DROIDCAM_PORT,
    path: DROIDCAM_PATH,
    method: 'GET',
    headers: {
      'User-Agent': 'MJPEG-Proxy',
      'Accept': 'multipart/x-mixed-replace'
    }
  }, (droidcamRes) => {
    console.log('âœ… Connected to DroidCam stream');
    
    let buffer = Buffer.alloc(0);
    let lastFrameTime = Date.now();
    
    droidcamRes.on('data', (chunk) => {
      buffer = Buffer.concat([buffer, chunk]);
      
      // Find JPEG frames in the buffer
      while (true) {
        const startIndex = buffer.indexOf(Buffer.from([0xFF, 0xD8]));
        if (startIndex === -1) break;
        
        const endIndex = buffer.indexOf(Buffer.from([0xFF, 0xD9]), startIndex);
        if (endIndex === -1) break;
        
        // Extract the JPEG frame
        const jpegFrame = buffer.slice(startIndex, endIndex + 2);
        
        // Send raw binary frame via WebSocket
        if (ws.readyState === WebSocket.OPEN) {
          // Calculate FPS
          const now = Date.now();
          const frameInterval = now - lastFrameTime;
          lastFrameTime = now;
          
          // Send frame with minimal metadata
          ws.send(JSON.stringify({
            type: 'frame',
            frame: frameCount++,
            fps: Math.round(1000 / frameInterval),
            size: jpegFrame.length
          }));
          
          // Send binary frame data
          ws.send(jpegFrame);
        }
        
        // Remove processed frame from buffer
        buffer = buffer.slice(endIndex + 2);
      }
    });
    
    droidcamRes.on('end', () => {
      console.log('âš ï¸ DroidCam stream ended');
      if (ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'end' }));
        ws.close();
      }
    });
    
    droidcamRes.on('error', (err) => {
      console.error('DroidCam stream error:', err);
      if (ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'error', error: err.message }));
        ws.close();
      }
    });
  });
  
  droidcamReq.on('error', (err) => {
    console.error('âŒ DroidCam connection error:', err.message);
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({ type: 'error', error: err.message }));
      ws.close();
    }
  });
  
  droidcamReq.end();
  
  // Store reference for cleanup
  droidcamConnection = droidcamReq;
  
  // Handle WebSocket close
  ws.on('close', () => {
    console.log('ðŸ”Œ WebSocket client disconnected');
    if (droidcamConnection) {
      droidcamConnection.destroy();
      droidcamConnection = null;
    }
  });
  
  ws.on('error', (error) => {
    console.error('WebSocket error:', error);
  });
});

/* --------------------------------------------------
   START SERVER
-------------------------------------------------- */
const PORT = 8080;
server.listen(PORT, () => {
  console.log(`ðŸš€ Real-Time Proxy Server running`);
  console.log(`âž¡ï¸  Display stream: http://localhost:${PORT}/video`);
  console.log(`âž¡ï¸  Binary stream:  ws://localhost:${PORT}`);
  console.log(`âž¡ï¸  Health:         http://localhost:${PORT}/health`);
});